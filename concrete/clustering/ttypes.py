# -*- coding: utf-8 -*-
#
# Autogenerated by Thrift Compiler (0.10.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
import sys
import concrete.uuid.ttypes
import concrete.metadata.ttypes

from thrift.transport import TTransport


class ClusterMember(object):
    """
    An item being clustered. Does not designate cluster _membership_, as in
    "item x belongs to cluster C", but rather just the item ("x" in this
    example). Membership is indicated through Cluster objects.  An item may be a
    Entity, EntityMention, Situation, SituationMention, or technically anything
    with a UUID.

    Attributes:
     - communicationId: UUID of the Communication which contains the item specified by 'elementId'.
    This is ancillary info assuming UUIDs are indeed universally unique.
     - setId: UUID of the Entity|Situation(Mention)Set which contains the item specified by 'elementId'.
    This is ancillary info assuming UUIDs are indeed universally unique.
     - elementId: UUID of the EntityMention, Entity, SituationMention, or Situation that
    this item represents. This is the characteristic field.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'communicationId', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'setId', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'elementId', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ),  # 3
    )

    def __init__(self, communicationId=None, setId=None, elementId=None,):
        self.communicationId = communicationId
        self.setId = setId
        self.elementId = elementId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.communicationId = concrete.uuid.ttypes.UUID()
                    self.communicationId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.setId = concrete.uuid.ttypes.UUID()
                    self.setId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.elementId = concrete.uuid.ttypes.UUID()
                    self.elementId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('ClusterMember')
        if self.communicationId is not None:
            oprot.writeFieldBegin('communicationId', TType.STRUCT, 1)
            self.communicationId.write(oprot)
            oprot.writeFieldEnd()
        if self.setId is not None:
            oprot.writeFieldBegin('setId', TType.STRUCT, 2)
            self.setId.write(oprot)
            oprot.writeFieldEnd()
        if self.elementId is not None:
            oprot.writeFieldBegin('elementId', TType.STRUCT, 3)
            self.elementId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.communicationId is None:
            raise TProtocolException(message='Required field communicationId is unset!')
        if self.setId is None:
            raise TProtocolException(message='Required field setId is unset!')
        if self.elementId is None:
            raise TProtocolException(message='Required field elementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Cluster(object):
    """
    A set of items which are alike in some way.  Has an implicit id which is the
    index of this Cluster in its parent Clustering's 'clusterList'.

    Attributes:
     - clusterMemberIndexList: The items in this cluster.  Values are indices into the
    'clusterMemberList' of the Clustering which contains this Cluster.
     - confidenceList: Co-indexed with 'clusterMemberIndexList'. The i^{th} value represents the
    confidence that mention clusterMemberIndexList[i] belongs to this cluster.
     - childIndexList: A set of clusters (implicit ids/indices) from which this cluster was
    created. This cluster should represent the union of all the items in all
    of the child clusters.  (For hierarchical clustering only).
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'clusterMemberIndexList', (TType.I32, None, False), None, ),  # 1
        (2, TType.LIST, 'confidenceList', (TType.DOUBLE, None, False), None, ),  # 2
        (3, TType.LIST, 'childIndexList', (TType.I32, None, False), None, ),  # 3
    )

    def __init__(self, clusterMemberIndexList=None, confidenceList=None, childIndexList=None,):
        self.clusterMemberIndexList = clusterMemberIndexList
        self.confidenceList = confidenceList
        self.childIndexList = childIndexList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.clusterMemberIndexList = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.clusterMemberIndexList.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.confidenceList = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readDouble()
                        self.confidenceList.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.childIndexList = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = iprot.readI32()
                        self.childIndexList.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('Cluster')
        if self.clusterMemberIndexList is not None:
            oprot.writeFieldBegin('clusterMemberIndexList', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.clusterMemberIndexList))
            for iter18 in self.clusterMemberIndexList:
                oprot.writeI32(iter18)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.confidenceList is not None:
            oprot.writeFieldBegin('confidenceList', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.confidenceList))
            for iter19 in self.confidenceList:
                oprot.writeDouble(iter19)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.childIndexList is not None:
            oprot.writeFieldBegin('childIndexList', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.childIndexList))
            for iter20 in self.childIndexList:
                oprot.writeI32(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Clustering(object):
    """
    An (optionally) hierarchical clustering of items appearing across a set of
    Communications (intra-Communication clusterings are encoded by Entities and
    Situations).  An item may be a Entity, EntityMention, Situation,
    SituationMention, or technically anything with a UUID.

    Attributes:
     - uuid: UUID for this Clustering object.
     - metadata: Metadata for this Clustering object.
     - clusterMemberList: The set of items being clustered.
     - clusterList: Clusters of items. If this is a hierarchical clustering, this may contain
    clusters which are the set of smaller clusters.
    Clusters may not "overlap", meaning (for all clusters X,Y):
      X \cap Y \neq \emptyset \implies X \subset Y \vee Y \subset X
     - rootClusterIndexList: A set of disjoint clusters (indices in 'clusterList') which cover all
    items in 'clusterMemberList'. This list must be specified for hierarchical
    clusterings and should not be specified for flat clusterings.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ),  # 2
        (3, TType.LIST, 'clusterMemberList', (TType.STRUCT, (ClusterMember, ClusterMember.thrift_spec), False), None, ),  # 3
        (4, TType.LIST, 'clusterList', (TType.STRUCT, (Cluster, Cluster.thrift_spec), False), None, ),  # 4
        (5, TType.LIST, 'rootClusterIndexList', (TType.I32, None, False), None, ),  # 5
    )

    def __init__(self, uuid=None, metadata=None, clusterMemberList=None, clusterList=None, rootClusterIndexList=None,):
        self.uuid = uuid
        self.metadata = metadata
        self.clusterMemberList = clusterMemberList
        self.clusterList = clusterList
        self.rootClusterIndexList = rootClusterIndexList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.clusterMemberList = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = ClusterMember()
                        _elem26.read(iprot)
                        self.clusterMemberList.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.clusterList = []
                    (_etype30, _size27) = iprot.readListBegin()
                    for _i31 in range(_size27):
                        _elem32 = Cluster()
                        _elem32.read(iprot)
                        self.clusterList.append(_elem32)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.rootClusterIndexList = []
                    (_etype36, _size33) = iprot.readListBegin()
                    for _i37 in range(_size33):
                        _elem38 = iprot.readI32()
                        self.rootClusterIndexList.append(_elem38)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('Clustering')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.clusterMemberList is not None:
            oprot.writeFieldBegin('clusterMemberList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.clusterMemberList))
            for iter39 in self.clusterMemberList:
                iter39.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.clusterList is not None:
            oprot.writeFieldBegin('clusterList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.clusterList))
            for iter40 in self.clusterList:
                iter40.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rootClusterIndexList is not None:
            oprot.writeFieldBegin('rootClusterIndexList', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.rootClusterIndexList))
            for iter41 in self.rootClusterIndexList:
                oprot.writeI32(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
