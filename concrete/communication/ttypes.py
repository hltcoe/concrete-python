# -*- coding: utf-8 -*-
#
# Autogenerated by Thrift Compiler (0.18.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import concrete.uuid.ttypes
import concrete.language.ttypes
import concrete.structure.ttypes
import concrete.entities.ttypes
import concrete.situations.ttypes
import concrete.audio.ttypes
import concrete.metadata.ttypes
import concrete.clustering.ttypes

from thrift.transport import TTransport
all_structs = []


class CommunicationTagging(object):
    """
    A structure that represents a 'tagging' of a Communication. These
    might be labels or annotations on a particular communcation.

    For example, this structure might be used to describe the topics
    discussed in a Communication. The taggingType might be 'topic', and
    the tagList might include 'politics' and 'science'.

    Attributes:
     - uuid: A unique identifier for this CommunicationTagging object.
     - metadata: AnnotationMetadata to support this CommunicationTagging object.
     - taggingType: A string that captures the type of this CommunicationTagging
    object. For example: 'topic' or 'gender'.
     - tagList: A list of strings that represent different tags related to the taggingType.
    For example, if the taggingType is 'topic', some example tags might be
    'politics', 'science', etc.
     - confidenceList: A list of doubles, parallel to the list of strings in tagList,
    that indicate the confidences of each tag.

    """


    def __init__(self, uuid=None, metadata=None, taggingType=None, tagList=None, confidenceList=None,):
        self.uuid = uuid
        self.metadata = metadata
        self.taggingType = taggingType
        self.tagList = tagList
        self.confidenceList = confidenceList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.taggingType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.tagList = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tagList.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.confidenceList = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readDouble()
                        self.confidenceList.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommunicationTagging')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.taggingType is not None:
            oprot.writeFieldBegin('taggingType', TType.STRING, 3)
            oprot.writeString(self.taggingType.encode('utf-8') if sys.version_info[0] == 2 else self.taggingType)
            oprot.writeFieldEnd()
        if self.tagList is not None:
            oprot.writeFieldBegin('tagList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.tagList))
            for iter12 in self.tagList:
                oprot.writeString(iter12.encode('utf-8') if sys.version_info[0] == 2 else iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.confidenceList is not None:
            oprot.writeFieldBegin('confidenceList', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.confidenceList))
            for iter13 in self.confidenceList:
                oprot.writeDouble(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        if self.taggingType is None:
            raise TProtocolException(message='Required field taggingType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Communication(object):
    """
    A single communication instance, containing linguistic content
    generated by a single speaker or author.  This type is used for
    both inter-personal communications (such as phone calls or
    conversations) and third-party communications (such as news
    articles).

    Each communication instance is grounded by its original
    (unannotated) contents, which should be stored in either the
    "text" field (for text communications) or the "audio" field (for
    audio communications).  If the communication is not available in
    its original form, then these fields should store the
    communication in the least-processed form available.

    Attributes:
     - id: Stable identifier for this communication, identifying both the
    name of the source corpus and the document that it corresponds to
    in that corpus.
     - uuid: Universally unique identifier for this communication instance.
    This is generated randomly, and can *not* be mapped back to the
    source corpus. It is used as a target for symbolic "pointers".
     - type: A short, corpus-specific term characterizing the nature of the
    communication; may change in a future version of concrete.
    Often used for filtering.  For example, Gigaword uses
    the type "story" to distinguish typical news articles from
    weekly summaries ("multi"), editorial advisories ("advis"), etc.
    At present, this value is typically a literal form from the
    originating corpus: as a result, a type marked 'other' may have
    different meanings across different corpora.
     - text: The full text contents of this communication in its original
    form, or in the least-processed form available, if the original
    is not available.
     - startTime: The time when this communication started (in unix time UTC --
    i.e., seconds since January 1, 1970).
     - endTime: The time when this communication ended (in unix time UTC --
    i.e., seconds since January 1, 1970).
     - communicationTaggingList: A list of CommunicationTagging objects that can support this
    Communication. CommunicationTagging objects can be used to
    annotate Communications with topics, gender identification, etc.
     - metadata: metadata.AnnotationMetadata to support this particular communication.

    Communications derived from other communications should
    indicate in this metadata object their dependency
    to the original communication ID.
     - keyValueMap: A catch-all store of keys and values. Use sparingly!
     - lidList: Theories about the languages that are present in this
    communication.
     - sectionList: Theory about the block structure of this communication.
     - entityMentionSetList: Theories about which spans of text are used to mention entities
    in this communication.
     - entitySetList: Theories about what entities are discussed in this
    communication, with pointers to individual mentions.
     - situationMentionSetList: Theories about what situations are explicitly mentioned in this
    communication.
     - situationSetList: Theories about what situations are asserted in this
    communication.
     - originalText: Optional original text field that points back to an original
    communication.

    This field can be populated for sake of convenience when creating
    "perspective" communication (communications that are based on
    highly destructive changes to an original communication [e.g.,
    via MT]). This allows developers to quickly access the original
    text that this perspective communication is based off of.
     - sound: The full audio contents of this communication in its original
    form, or in the least-processed form available, if the original
    is not available.
     - communicationMetadata: Metadata about this specific Communication, such as information
    about its author, information specific to this Communication
    or Communications like it (info from an API, for example), etc.

    """


    def __init__(self, id=None, uuid=None, type=None, text=None, startTime=None, endTime=None, communicationTaggingList=None, metadata=None, keyValueMap=None, lidList=None, sectionList=None, entityMentionSetList=None, entitySetList=None, situationMentionSetList=None, situationSetList=None, originalText=None, sound=None, communicationMetadata=None,):
        self.id = id
        self.uuid = uuid
        self.type = type
        self.text = text
        self.startTime = startTime
        self.endTime = endTime
        self.communicationTaggingList = communicationTaggingList
        self.metadata = metadata
        self.keyValueMap = keyValueMap
        self.lidList = lidList
        self.sectionList = sectionList
        self.entityMentionSetList = entityMentionSetList
        self.entitySetList = entitySetList
        self.situationMentionSetList = situationMentionSetList
        self.situationSetList = situationSetList
        self.originalText = originalText
        self.sound = sound
        self.communicationMetadata = communicationMetadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.text = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.communicationTaggingList = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = CommunicationTagging()
                        _elem19.read(iprot)
                        self.communicationTaggingList.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.keyValueMap = {}
                    (_ktype21, _vtype22, _size20) = iprot.readMapBegin()
                    for _i24 in range(_size20):
                        _key25 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val26 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyValueMap[_key25] = _val26
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.lidList = []
                    (_etype30, _size27) = iprot.readListBegin()
                    for _i31 in range(_size27):
                        _elem32 = concrete.language.ttypes.LanguageIdentification()
                        _elem32.read(iprot)
                        self.lidList.append(_elem32)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.sectionList = []
                    (_etype36, _size33) = iprot.readListBegin()
                    for _i37 in range(_size33):
                        _elem38 = concrete.structure.ttypes.Section()
                        _elem38.read(iprot)
                        self.sectionList.append(_elem38)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.LIST:
                    self.entityMentionSetList = []
                    (_etype42, _size39) = iprot.readListBegin()
                    for _i43 in range(_size39):
                        _elem44 = concrete.entities.ttypes.EntityMentionSet()
                        _elem44.read(iprot)
                        self.entityMentionSetList.append(_elem44)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.entitySetList = []
                    (_etype48, _size45) = iprot.readListBegin()
                    for _i49 in range(_size45):
                        _elem50 = concrete.entities.ttypes.EntitySet()
                        _elem50.read(iprot)
                        self.entitySetList.append(_elem50)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.LIST:
                    self.situationMentionSetList = []
                    (_etype54, _size51) = iprot.readListBegin()
                    for _i55 in range(_size51):
                        _elem56 = concrete.situations.ttypes.SituationMentionSet()
                        _elem56.read(iprot)
                        self.situationMentionSetList.append(_elem56)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.LIST:
                    self.situationSetList = []
                    (_etype60, _size57) = iprot.readListBegin()
                    for _i61 in range(_size57):
                        _elem62 = concrete.situations.ttypes.SituationSet()
                        _elem62.read(iprot)
                        self.situationSetList.append(_elem62)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRING:
                    self.originalText = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRUCT:
                    self.sound = concrete.audio.ttypes.Sound()
                    self.sound.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRUCT:
                    self.communicationMetadata = concrete.metadata.ttypes.CommunicationMetadata()
                    self.communicationMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Communication')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 2)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 3)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        if self.text is not None:
            oprot.writeFieldBegin('text', TType.STRING, 4)
            oprot.writeString(self.text.encode('utf-8') if sys.version_info[0] == 2 else self.text)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 5)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 6)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.communicationTaggingList is not None:
            oprot.writeFieldBegin('communicationTaggingList', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.communicationTaggingList))
            for iter63 in self.communicationTaggingList:
                iter63.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 8)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.keyValueMap is not None:
            oprot.writeFieldBegin('keyValueMap', TType.MAP, 9)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyValueMap))
            for kiter64, viter65 in self.keyValueMap.items():
                oprot.writeString(kiter64.encode('utf-8') if sys.version_info[0] == 2 else kiter64)
                oprot.writeString(viter65.encode('utf-8') if sys.version_info[0] == 2 else viter65)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.lidList is not None:
            oprot.writeFieldBegin('lidList', TType.LIST, 10)
            oprot.writeListBegin(TType.STRUCT, len(self.lidList))
            for iter66 in self.lidList:
                iter66.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sectionList is not None:
            oprot.writeFieldBegin('sectionList', TType.LIST, 11)
            oprot.writeListBegin(TType.STRUCT, len(self.sectionList))
            for iter67 in self.sectionList:
                iter67.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.entityMentionSetList is not None:
            oprot.writeFieldBegin('entityMentionSetList', TType.LIST, 12)
            oprot.writeListBegin(TType.STRUCT, len(self.entityMentionSetList))
            for iter68 in self.entityMentionSetList:
                iter68.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.entitySetList is not None:
            oprot.writeFieldBegin('entitySetList', TType.LIST, 13)
            oprot.writeListBegin(TType.STRUCT, len(self.entitySetList))
            for iter69 in self.entitySetList:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.situationMentionSetList is not None:
            oprot.writeFieldBegin('situationMentionSetList', TType.LIST, 14)
            oprot.writeListBegin(TType.STRUCT, len(self.situationMentionSetList))
            for iter70 in self.situationMentionSetList:
                iter70.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.situationSetList is not None:
            oprot.writeFieldBegin('situationSetList', TType.LIST, 15)
            oprot.writeListBegin(TType.STRUCT, len(self.situationSetList))
            for iter71 in self.situationSetList:
                iter71.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.originalText is not None:
            oprot.writeFieldBegin('originalText', TType.STRING, 16)
            oprot.writeString(self.originalText.encode('utf-8') if sys.version_info[0] == 2 else self.originalText)
            oprot.writeFieldEnd()
        if self.sound is not None:
            oprot.writeFieldBegin('sound', TType.STRUCT, 20)
            self.sound.write(oprot)
            oprot.writeFieldEnd()
        if self.communicationMetadata is not None:
            oprot.writeFieldBegin('communicationMetadata', TType.STRUCT, 21)
            self.communicationMetadata.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CommunicationSet(object):
    """
    A structure that represents a collection of Communications.

    Attributes:
     - communicationIdList: A list of Communication UUIDs that this CommunicationSet
    represents.

    This field may be absent if this CommunicationSet represents
    a large corpus. If absent, 'corpus' field should be present.
     - corpus: The name of a corpus or other document body that this
    CommunicationSet represents.

    Should be present if 'communicationIdList' is absent.
     - entityMentionClusterList: A list of Clustering objects that represent a
    group of EntityMentions that are a part of this
    CommunicationSet.
     - entityClusterList: A list of Clustering objects that represent a
    group of Entities that are a part of this
    CommunicationSet.
     - situationMentionClusterList: A list of Clustering objects that represent a
    group of SituationMentions that are a part of this
    CommunicationSet.
     - situationClusterList: A list of Clustering objects that represent a
    group of Situations that are a part of this
    CommunicationSet.

    """


    def __init__(self, communicationIdList=None, corpus=None, entityMentionClusterList=None, entityClusterList=None, situationMentionClusterList=None, situationClusterList=None,):
        self.communicationIdList = communicationIdList
        self.corpus = corpus
        self.entityMentionClusterList = entityMentionClusterList
        self.entityClusterList = entityClusterList
        self.situationMentionClusterList = situationMentionClusterList
        self.situationClusterList = situationClusterList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.communicationIdList = []
                    (_etype75, _size72) = iprot.readListBegin()
                    for _i76 in range(_size72):
                        _elem77 = concrete.uuid.ttypes.UUID()
                        _elem77.read(iprot)
                        self.communicationIdList.append(_elem77)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.corpus = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.entityMentionClusterList = []
                    (_etype81, _size78) = iprot.readListBegin()
                    for _i82 in range(_size78):
                        _elem83 = concrete.clustering.ttypes.Clustering()
                        _elem83.read(iprot)
                        self.entityMentionClusterList.append(_elem83)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.entityClusterList = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = concrete.clustering.ttypes.Clustering()
                        _elem89.read(iprot)
                        self.entityClusterList.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.situationMentionClusterList = []
                    (_etype93, _size90) = iprot.readListBegin()
                    for _i94 in range(_size90):
                        _elem95 = concrete.clustering.ttypes.Clustering()
                        _elem95.read(iprot)
                        self.situationMentionClusterList.append(_elem95)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.situationClusterList = []
                    (_etype99, _size96) = iprot.readListBegin()
                    for _i100 in range(_size96):
                        _elem101 = concrete.clustering.ttypes.Clustering()
                        _elem101.read(iprot)
                        self.situationClusterList.append(_elem101)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommunicationSet')
        if self.communicationIdList is not None:
            oprot.writeFieldBegin('communicationIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.communicationIdList))
            for iter102 in self.communicationIdList:
                iter102.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.corpus is not None:
            oprot.writeFieldBegin('corpus', TType.STRING, 2)
            oprot.writeString(self.corpus.encode('utf-8') if sys.version_info[0] == 2 else self.corpus)
            oprot.writeFieldEnd()
        if self.entityMentionClusterList is not None:
            oprot.writeFieldBegin('entityMentionClusterList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.entityMentionClusterList))
            for iter103 in self.entityMentionClusterList:
                iter103.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.entityClusterList is not None:
            oprot.writeFieldBegin('entityClusterList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.entityClusterList))
            for iter104 in self.entityClusterList:
                iter104.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.situationMentionClusterList is not None:
            oprot.writeFieldBegin('situationMentionClusterList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.situationMentionClusterList))
            for iter105 in self.situationMentionClusterList:
                iter105.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.situationClusterList is not None:
            oprot.writeFieldBegin('situationClusterList', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.situationClusterList))
            for iter106 in self.situationClusterList:
                iter106.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CommunicationTagging)
CommunicationTagging.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'uuid', [concrete.uuid.ttypes.UUID, None], None, ),  # 1
    (2, TType.STRUCT, 'metadata', [concrete.metadata.ttypes.AnnotationMetadata, None], None, ),  # 2
    (3, TType.STRING, 'taggingType', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'tagList', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'confidenceList', (TType.DOUBLE, None, False), None, ),  # 5
)
all_structs.append(Communication)
Communication.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'uuid', [concrete.uuid.ttypes.UUID, None], None, ),  # 2
    (3, TType.STRING, 'type', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'text', 'UTF8', None, ),  # 4
    (5, TType.I64, 'startTime', None, None, ),  # 5
    (6, TType.I64, 'endTime', None, None, ),  # 6
    (7, TType.LIST, 'communicationTaggingList', (TType.STRUCT, [CommunicationTagging, None], False), None, ),  # 7
    (8, TType.STRUCT, 'metadata', [concrete.metadata.ttypes.AnnotationMetadata, None], None, ),  # 8
    (9, TType.MAP, 'keyValueMap', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 9
    (10, TType.LIST, 'lidList', (TType.STRUCT, [concrete.language.ttypes.LanguageIdentification, None], False), None, ),  # 10
    (11, TType.LIST, 'sectionList', (TType.STRUCT, [concrete.structure.ttypes.Section, None], False), None, ),  # 11
    (12, TType.LIST, 'entityMentionSetList', (TType.STRUCT, [concrete.entities.ttypes.EntityMentionSet, None], False), None, ),  # 12
    (13, TType.LIST, 'entitySetList', (TType.STRUCT, [concrete.entities.ttypes.EntitySet, None], False), None, ),  # 13
    (14, TType.LIST, 'situationMentionSetList', (TType.STRUCT, [concrete.situations.ttypes.SituationMentionSet, None], False), None, ),  # 14
    (15, TType.LIST, 'situationSetList', (TType.STRUCT, [concrete.situations.ttypes.SituationSet, None], False), None, ),  # 15
    (16, TType.STRING, 'originalText', 'UTF8', None, ),  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.STRUCT, 'sound', [concrete.audio.ttypes.Sound, None], None, ),  # 20
    (21, TType.STRUCT, 'communicationMetadata', [concrete.metadata.ttypes.CommunicationMetadata, None], None, ),  # 21
)
all_structs.append(CommunicationSet)
CommunicationSet.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'communicationIdList', (TType.STRUCT, [concrete.uuid.ttypes.UUID, None], False), None, ),  # 1
    (2, TType.STRING, 'corpus', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'entityMentionClusterList', (TType.STRUCT, [concrete.clustering.ttypes.Clustering, None], False), None, ),  # 3
    (4, TType.LIST, 'entityClusterList', (TType.STRUCT, [concrete.clustering.ttypes.Clustering, None], False), None, ),  # 4
    (5, TType.LIST, 'situationMentionClusterList', (TType.STRUCT, [concrete.clustering.ttypes.Clustering, None], False), None, ),  # 5
    (6, TType.LIST, 'situationClusterList', (TType.STRUCT, [concrete.clustering.ttypes.Clustering, None], False), None, ),  # 6
)
fix_spec(all_structs)
del all_structs
