# -*- coding: utf-8 -*-
#
# Autogenerated by Thrift Compiler (0.17.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import concrete.property.ttypes
import concrete.structure.ttypes
import concrete.metadata.ttypes
import concrete.uuid.ttypes
import concrete.linking.ttypes

from thrift.transport import TTransport
all_structs = []


class Argument(object):
    """
    A situation argument, consisting of an argument role and a value.
    Argument values may be Entities or Situations.

    Attributes:
     - role: The relationship between this argument and the situation that
    owns it. The roles that a situation's arguments can take
    depend on the type of the situation (including subtype
    information, such as event_type).
     - entityId: A pointer to the value of this argument, if it is explicitly
    encoded as an Entity.
     - situationId: A pointer to the value of this argument, if it is a situation.
     - propertyList: For multi-label tasks, more than one property can be attached to
    a single participant. A list of these properties can be stored in
    this field.

    """


    def __init__(self, role=None, entityId=None, situationId=None, propertyList=None,):
        self.role = role
        self.entityId = entityId
        self.situationId = situationId
        self.propertyList = propertyList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.role = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.entityId = concrete.uuid.ttypes.UUID()
                    self.entityId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.situationId = concrete.uuid.ttypes.UUID()
                    self.situationId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.propertyList = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = concrete.property.ttypes.Property()
                        _elem5.read(iprot)
                        self.propertyList.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Argument')
        if self.role is not None:
            oprot.writeFieldBegin('role', TType.STRING, 1)
            oprot.writeString(self.role.encode('utf-8') if sys.version_info[0] == 2 else self.role)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRUCT, 2)
            self.entityId.write(oprot)
            oprot.writeFieldEnd()
        if self.situationId is not None:
            oprot.writeFieldBegin('situationId', TType.STRUCT, 3)
            self.situationId.write(oprot)
            oprot.writeFieldEnd()
        if self.propertyList is not None:
            oprot.writeFieldBegin('propertyList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.propertyList))
            for iter6 in self.propertyList:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Justification(object):
    """
    Attributes:
     - justificationType: An enumerated value used to describe the way in which the
    justification's mention provides supporting evidence for the
    situation.
     - mentionId: A pointer to the SituationMention itself.
     - tokenRefSeqList: An optional list of pointers to tokens that are (especially)
    relevant to the way in which this mention provides
    justification for the situation. It is left up to individual
    analytics to decide what tokens (if any) they wish to include
    in this field.

    """


    def __init__(self, justificationType=None, mentionId=None, tokenRefSeqList=None,):
        self.justificationType = justificationType
        self.mentionId = mentionId
        self.tokenRefSeqList = tokenRefSeqList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.justificationType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.mentionId = concrete.uuid.ttypes.UUID()
                    self.mentionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tokenRefSeqList = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = concrete.structure.ttypes.TokenRefSequence()
                        _elem12.read(iprot)
                        self.tokenRefSeqList.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Justification')
        if self.justificationType is not None:
            oprot.writeFieldBegin('justificationType', TType.STRING, 1)
            oprot.writeString(self.justificationType.encode('utf-8') if sys.version_info[0] == 2 else self.justificationType)
            oprot.writeFieldEnd()
        if self.mentionId is not None:
            oprot.writeFieldBegin('mentionId', TType.STRUCT, 2)
            self.mentionId.write(oprot)
            oprot.writeFieldEnd()
        if self.tokenRefSeqList is not None:
            oprot.writeFieldBegin('tokenRefSeqList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.tokenRefSeqList))
            for iter13 in self.tokenRefSeqList:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.mentionId is None:
            raise TProtocolException(message='Required field mentionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TimeML(object):
    """
    A wrapper for various TimeML annotations.

    Attributes:
     - timeMLClass: The TimeML class for situations representing TimeML events
     - timeMLTense: The TimeML tense for situations representing TimeML events
     - timeMLAspect: The TimeML aspect for situations representing TimeML events

    """


    def __init__(self, timeMLClass=None, timeMLTense=None, timeMLAspect=None,):
        self.timeMLClass = timeMLClass
        self.timeMLTense = timeMLTense
        self.timeMLAspect = timeMLAspect

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.timeMLClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timeMLTense = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timeMLAspect = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TimeML')
        if self.timeMLClass is not None:
            oprot.writeFieldBegin('timeMLClass', TType.STRING, 1)
            oprot.writeString(self.timeMLClass.encode('utf-8') if sys.version_info[0] == 2 else self.timeMLClass)
            oprot.writeFieldEnd()
        if self.timeMLTense is not None:
            oprot.writeFieldBegin('timeMLTense', TType.STRING, 2)
            oprot.writeString(self.timeMLTense.encode('utf-8') if sys.version_info[0] == 2 else self.timeMLTense)
            oprot.writeFieldEnd()
        if self.timeMLAspect is not None:
            oprot.writeFieldBegin('timeMLAspect', TType.STRING, 3)
            oprot.writeString(self.timeMLAspect.encode('utf-8') if sys.version_info[0] == 2 else self.timeMLAspect)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Situation(object):
    """
    A single situation, along with pointers to situation mentions that
    provide evidence for the situation. "Situations" include events,
    relations, facts, sentiments, and beliefs. Each situation has a
    core type (such as EVENT or SENTIMENT), along with an optional
    subtype based on its core type (e.g., event_type=CONTACT_MEET), and
    a set of zero or more unordered arguments.

    This struct may be used for a variety of "processed" Situations such
    as (but not limited to):
    - SituationMentions which have been collapsed into a coreferential cluster
    - Situations which are inferred and not directly supported by a textual mention

    Attributes:
     - uuid: Unique identifier for this situation.
     - id: A corpus-specific and stable id akin to a Freebase mid
    or a DBpedia id.
     - situationType: The core type of this situation (eg EVENT or SENTIMENT),
    or a coarse grain situation type.
     - situationKind: A fine grain situation type that specifically describes the
    situation based on situationType above. It allows for more
    detailed description of the situation.

    Some examples:

    if situationType == EVENT, the event type for the situation
    if situationType == STATE, the state type
    if situationType == TEMPORAL_FACT, the temporal fact type

    For Propbank, this field should be the predicate lemma and id,
    e.g. "strike.02". For FrameNet, this should be the frame name,
    e.g. "Commerce_buy".

    Different and more varied situationTypes may be added
    in the future.
     - argumentList: The arguments for this situation. Each argument consists of a
    role and a value. It is possible for an situation to have
    multiple arguments with the same role. Arguments are
    unordered.
     - mentionIdList: Ids of the mentions of this situation in a communication
    (type=SituationMention)
     - justificationList: An list of pointers to SituationMentions that provide
    justification for this situation. These mentions may be either
    direct mentions of the situation, or indirect evidence.
     - canonicalName: A string containing a representative, canonical, or "best" name
    for this situations's referent.  This string may match one of the
    mentions' text strings, but it is not required to.
     - timeML: A wrapper for TimeML annotations.
     - intensity: An "intensity" rating for this situation, typically ranging from
    0-1. In the case of SENTIMENT situations, this is used to record
    the intensity of the sentiment.
     - polarity: The polarity of this situation. In the case of SENTIMENT
    situations, this is used to record the polarity of the
    sentiment.
     - confidence: A confidence score for this individual situation. You can also
    set a confidence score for an entire SituationSet using the
    SituationSet's metadata.
     - propertyList: For multi-label tasks, more than one property can be attached to
    a single situation. A list of these properties can be stored in
    this field.

    """


    def __init__(self, uuid=None, id=None, situationType=None, situationKind=None, argumentList=None, mentionIdList=None, justificationList=None, canonicalName=None, timeML=None, intensity=None, polarity=None, confidence=None, propertyList=None,):
        self.uuid = uuid
        self.id = id
        self.situationType = situationType
        self.situationKind = situationKind
        self.argumentList = argumentList
        self.mentionIdList = mentionIdList
        self.justificationList = justificationList
        self.canonicalName = canonicalName
        self.timeML = timeML
        self.intensity = intensity
        self.polarity = polarity
        self.confidence = confidence
        self.propertyList = propertyList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.situationType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 50:
                if ftype == TType.STRING:
                    self.situationKind = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.argumentList = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = Argument()
                        _elem19.read(iprot)
                        self.argumentList.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.mentionIdList = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = concrete.uuid.ttypes.UUID()
                        _elem25.read(iprot)
                        self.mentionIdList.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.justificationList = []
                    (_etype29, _size26) = iprot.readListBegin()
                    for _i30 in range(_size26):
                        _elem31 = Justification()
                        _elem31.read(iprot)
                        self.justificationList.append(_elem31)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.canonicalName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 54:
                if ftype == TType.STRUCT:
                    self.timeML = TimeML()
                    self.timeML.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 100:
                if ftype == TType.DOUBLE:
                    self.intensity = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 101:
                if ftype == TType.STRING:
                    self.polarity = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 200:
                if ftype == TType.DOUBLE:
                    self.confidence = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 300:
                if ftype == TType.LIST:
                    self.propertyList = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = concrete.property.ttypes.Property()
                        _elem37.read(iprot)
                        self.propertyList.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Situation')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.situationType is not None:
            oprot.writeFieldBegin('situationType', TType.STRING, 2)
            oprot.writeString(self.situationType.encode('utf-8') if sys.version_info[0] == 2 else self.situationType)
            oprot.writeFieldEnd()
        if self.argumentList is not None:
            oprot.writeFieldBegin('argumentList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.argumentList))
            for iter38 in self.argumentList:
                iter38.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.mentionIdList is not None:
            oprot.writeFieldBegin('mentionIdList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.mentionIdList))
            for iter39 in self.mentionIdList:
                iter39.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.justificationList is not None:
            oprot.writeFieldBegin('justificationList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.justificationList))
            for iter40 in self.justificationList:
                iter40.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 6)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.canonicalName is not None:
            oprot.writeFieldBegin('canonicalName', TType.STRING, 7)
            oprot.writeString(self.canonicalName.encode('utf-8') if sys.version_info[0] == 2 else self.canonicalName)
            oprot.writeFieldEnd()
        if self.situationKind is not None:
            oprot.writeFieldBegin('situationKind', TType.STRING, 50)
            oprot.writeString(self.situationKind.encode('utf-8') if sys.version_info[0] == 2 else self.situationKind)
            oprot.writeFieldEnd()
        if self.timeML is not None:
            oprot.writeFieldBegin('timeML', TType.STRUCT, 54)
            self.timeML.write(oprot)
            oprot.writeFieldEnd()
        if self.intensity is not None:
            oprot.writeFieldBegin('intensity', TType.DOUBLE, 100)
            oprot.writeDouble(self.intensity)
            oprot.writeFieldEnd()
        if self.polarity is not None:
            oprot.writeFieldBegin('polarity', TType.STRING, 101)
            oprot.writeString(self.polarity.encode('utf-8') if sys.version_info[0] == 2 else self.polarity)
            oprot.writeFieldEnd()
        if self.confidence is not None:
            oprot.writeFieldBegin('confidence', TType.DOUBLE, 200)
            oprot.writeDouble(self.confidence)
            oprot.writeFieldEnd()
        if self.propertyList is not None:
            oprot.writeFieldBegin('propertyList', TType.LIST, 300)
            oprot.writeListBegin(TType.STRUCT, len(self.propertyList))
            for iter41 in self.propertyList:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.situationType is None:
            raise TProtocolException(message='Required field situationType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SituationSet(object):
    """
    A theory about the set of situations that are present in a
    message. See also: Situation

    Attributes:
     - uuid: Unique identifier for this set.
     - metadata: Information about where this set came from.
     - situationList: List of mentions in this set.
     - linkingList: Entity linking annotations associated with this SituationSet.

    """


    def __init__(self, uuid=None, metadata=None, situationList=None, linkingList=None,):
        self.uuid = uuid
        self.metadata = metadata
        self.situationList = situationList
        self.linkingList = linkingList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.situationList = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = Situation()
                        _elem47.read(iprot)
                        self.situationList.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.linkingList = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = concrete.linking.ttypes.Linking()
                        _elem53.read(iprot)
                        self.linkingList.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SituationSet')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.situationList is not None:
            oprot.writeFieldBegin('situationList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.situationList))
            for iter54 in self.situationList:
                iter54.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.linkingList is not None:
            oprot.writeFieldBegin('linkingList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.linkingList))
            for iter55 in self.linkingList:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        if self.situationList is None:
            raise TProtocolException(message='Required field situationList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MentionArgument(object):
    """
    A "concrete" argument, that may be used by SituationMentions or EntityMentions
    to avoid conflicts where abstract Arguments were being used to support concrete Mentions.

    Attributes:
     - role: The relationship between this argument and the situation that
    owns it. The roles that a situation's arguments can take
    depend on the type of the situation (including subtype
    information, such as event_type).
     - entityMentionId: A pointer to the value of an EntityMention, if this is being used to support
    an EntityMention.
     - situationMentionId: A pointer to the value of this argument, if it is a SituationMention.
     - tokens: The location of this MentionArgument in the Communication.
    If this MentionArgument can be identified in a document using an
    EntityMention or SituationMention, then UUID references to those
    types should be preferred and this field left as null.
     - confidence: Confidence of this argument belonging to its SituationMention
     - propertyList: For multi-label tasks, more than one property can be attached to
    a single participant. A list of these properties can be stored in
    this field.

    """


    def __init__(self, role=None, entityMentionId=None, situationMentionId=None, tokens=None, confidence=None, propertyList=None,):
        self.role = role
        self.entityMentionId = entityMentionId
        self.situationMentionId = situationMentionId
        self.tokens = tokens
        self.confidence = confidence
        self.propertyList = propertyList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.role = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.entityMentionId = concrete.uuid.ttypes.UUID()
                    self.entityMentionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.situationMentionId = concrete.uuid.ttypes.UUID()
                    self.situationMentionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.tokens = concrete.structure.ttypes.TokenRefSequence()
                    self.tokens.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.confidence = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.propertyList = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = concrete.property.ttypes.Property()
                        _elem61.read(iprot)
                        self.propertyList.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MentionArgument')
        if self.role is not None:
            oprot.writeFieldBegin('role', TType.STRING, 1)
            oprot.writeString(self.role.encode('utf-8') if sys.version_info[0] == 2 else self.role)
            oprot.writeFieldEnd()
        if self.entityMentionId is not None:
            oprot.writeFieldBegin('entityMentionId', TType.STRUCT, 2)
            self.entityMentionId.write(oprot)
            oprot.writeFieldEnd()
        if self.situationMentionId is not None:
            oprot.writeFieldBegin('situationMentionId', TType.STRUCT, 3)
            self.situationMentionId.write(oprot)
            oprot.writeFieldEnd()
        if self.tokens is not None:
            oprot.writeFieldBegin('tokens', TType.STRUCT, 4)
            self.tokens.write(oprot)
            oprot.writeFieldEnd()
        if self.confidence is not None:
            oprot.writeFieldBegin('confidence', TType.DOUBLE, 5)
            oprot.writeDouble(self.confidence)
            oprot.writeFieldEnd()
        if self.propertyList is not None:
            oprot.writeFieldBegin('propertyList', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.propertyList))
            for iter62 in self.propertyList:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SituationMention(object):
    """
    A concrete mention of a situation, where "situations" include
    events, relations, facts, sentiments, and beliefs. Each situation
    has a core type (such as EVENT or SENTIMENT), along with an
    optional subtype based on its core type (e.g.,
    event_type=CONTACT_MEET), and a set of zero or more unordered
    arguments.

    This struct should be used for most types of SRL labelings
    (e.g. Propbank and FrameNet) because they are grounded in text.

    Attributes:
     - uuid: Unique identifier for this situation.
     - id: A corpus-specific and stable id akin to a Freebase mid
    or a DBpedia id.
     - text: The text content of this situation mention. This field is
    often redundant with the 'tokens' field, and may not
    be generated by all analytics.
     - situationType: The core type of this situation (eg EVENT or SENTIMENT),
    or a coarse grain situation type.
     - situationKind: A fine grain situation type that specifically describes the
    situation mention based on situationType above. It allows for
    more detailed description of the situation mention.

    Some examples:

    if situationType == EVENT, the event type for the sit. mention
    if situationType == STATE, the state type for this sit. mention

    For Propbank, this field should be the predicate lemma and id,
    e.g. "strike.02". For FrameNet, this should be the frame name,
    e.g. "Commerce_buy".

    Different and more varied situationTypes may be added
    in the future.
     - argumentList: The arguments for this situation mention. Each argument
    consists of a role and a value. It is possible for an situation
    to have multiple arguments with the same role. Arguments are
    unordered.
     - intensity: An "intensity" rating for the situation, typically ranging from
    0-1. In the case of SENTIMENT situations, this is used to record
    the intensity of the sentiment.
     - polarity: The polarity of this situation. In the case of SENTIMENT
    situations, this is used to record the polarity of the
    sentiment.
     - tokens: An optional pointer to tokens that are (especially)
    relevant to this situation mention. It is left up to individual
    analytics to decide what tokens (if any) they wish to include in
    this field. In particular, it is not specified whether the
    arguments' tokens should be included.
     - confidence: A confidence score for this individual situation mention. You
    can also set a confidence score for an entire SituationMentionSet
    using the SituationMentionSet's metadata.
     - propertyList: For multi-label tasks, more than one property can be attached to
    a single situation mention. A list of these properties can be
    stored in this field.

    """


    def __init__(self, uuid=None, id=None, text=None, situationType=None, situationKind=None, argumentList=None, intensity=None, polarity=None, tokens=None, confidence=None, propertyList=None,):
        self.uuid = uuid
        self.id = id
        self.text = text
        self.situationType = situationType
        self.situationKind = situationKind
        self.argumentList = argumentList
        self.intensity = intensity
        self.polarity = polarity
        self.tokens = tokens
        self.confidence = confidence
        self.propertyList = propertyList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.text = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.situationType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 50:
                if ftype == TType.STRING:
                    self.situationKind = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.argumentList = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = MentionArgument()
                        _elem68.read(iprot)
                        self.argumentList.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 100:
                if ftype == TType.DOUBLE:
                    self.intensity = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 101:
                if ftype == TType.STRING:
                    self.polarity = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 150:
                if ftype == TType.STRUCT:
                    self.tokens = concrete.structure.ttypes.TokenRefSequence()
                    self.tokens.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 200:
                if ftype == TType.DOUBLE:
                    self.confidence = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 300:
                if ftype == TType.LIST:
                    self.propertyList = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = concrete.property.ttypes.Property()
                        _elem74.read(iprot)
                        self.propertyList.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SituationMention')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.text is not None:
            oprot.writeFieldBegin('text', TType.STRING, 2)
            oprot.writeString(self.text.encode('utf-8') if sys.version_info[0] == 2 else self.text)
            oprot.writeFieldEnd()
        if self.situationType is not None:
            oprot.writeFieldBegin('situationType', TType.STRING, 3)
            oprot.writeString(self.situationType.encode('utf-8') if sys.version_info[0] == 2 else self.situationType)
            oprot.writeFieldEnd()
        if self.argumentList is not None:
            oprot.writeFieldBegin('argumentList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.argumentList))
            for iter75 in self.argumentList:
                iter75.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 5)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.situationKind is not None:
            oprot.writeFieldBegin('situationKind', TType.STRING, 50)
            oprot.writeString(self.situationKind.encode('utf-8') if sys.version_info[0] == 2 else self.situationKind)
            oprot.writeFieldEnd()
        if self.intensity is not None:
            oprot.writeFieldBegin('intensity', TType.DOUBLE, 100)
            oprot.writeDouble(self.intensity)
            oprot.writeFieldEnd()
        if self.polarity is not None:
            oprot.writeFieldBegin('polarity', TType.STRING, 101)
            oprot.writeString(self.polarity.encode('utf-8') if sys.version_info[0] == 2 else self.polarity)
            oprot.writeFieldEnd()
        if self.tokens is not None:
            oprot.writeFieldBegin('tokens', TType.STRUCT, 150)
            self.tokens.write(oprot)
            oprot.writeFieldEnd()
        if self.confidence is not None:
            oprot.writeFieldBegin('confidence', TType.DOUBLE, 200)
            oprot.writeDouble(self.confidence)
            oprot.writeFieldEnd()
        if self.propertyList is not None:
            oprot.writeFieldBegin('propertyList', TType.LIST, 300)
            oprot.writeListBegin(TType.STRUCT, len(self.propertyList))
            for iter76 in self.propertyList:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.argumentList is None:
            raise TProtocolException(message='Required field argumentList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SituationMentionSet(object):
    """
    A theory about the set of situation mentions that are present in a
    message. See also: SituationMention

    Attributes:
     - uuid: Unique identifier for this set.
     - metadata: Information about where this set came from.
     - mentionList: List of mentions in this set.
     - linkingList: Entity linking annotations associated with this SituationMentionSet.

    """


    def __init__(self, uuid=None, metadata=None, mentionList=None, linkingList=None,):
        self.uuid = uuid
        self.metadata = metadata
        self.mentionList = mentionList
        self.linkingList = linkingList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.mentionList = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = SituationMention()
                        _elem82.read(iprot)
                        self.mentionList.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.linkingList = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = concrete.linking.ttypes.Linking()
                        _elem88.read(iprot)
                        self.linkingList.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SituationMentionSet')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.mentionList is not None:
            oprot.writeFieldBegin('mentionList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.mentionList))
            for iter89 in self.mentionList:
                iter89.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.linkingList is not None:
            oprot.writeFieldBegin('linkingList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.linkingList))
            for iter90 in self.linkingList:
                iter90.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        if self.mentionList is None:
            raise TProtocolException(message='Required field mentionList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Argument)
Argument.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'role', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'entityId', [concrete.uuid.ttypes.UUID, None], None, ),  # 2
    (3, TType.STRUCT, 'situationId', [concrete.uuid.ttypes.UUID, None], None, ),  # 3
    (4, TType.LIST, 'propertyList', (TType.STRUCT, [concrete.property.ttypes.Property, None], False), None, ),  # 4
)
all_structs.append(Justification)
Justification.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'justificationType', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'mentionId', [concrete.uuid.ttypes.UUID, None], None, ),  # 2
    (3, TType.LIST, 'tokenRefSeqList', (TType.STRUCT, [concrete.structure.ttypes.TokenRefSequence, None], False), None, ),  # 3
)
all_structs.append(TimeML)
TimeML.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'timeMLClass', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'timeMLTense', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timeMLAspect', 'UTF8', None, ),  # 3
)
all_structs.append(Situation)
Situation.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'uuid', [concrete.uuid.ttypes.UUID, None], None, ),  # 1
    (2, TType.STRING, 'situationType', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'argumentList', (TType.STRUCT, [Argument, None], False), None, ),  # 3
    (4, TType.LIST, 'mentionIdList', (TType.STRUCT, [concrete.uuid.ttypes.UUID, None], False), None, ),  # 4
    (5, TType.LIST, 'justificationList', (TType.STRUCT, [Justification, None], False), None, ),  # 5
    (6, TType.STRING, 'id', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'canonicalName', 'UTF8', None, ),  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    (50, TType.STRING, 'situationKind', 'UTF8', None, ),  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    (54, TType.STRUCT, 'timeML', [TimeML, None], None, ),  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    (100, TType.DOUBLE, 'intensity', None, None, ),  # 100
    (101, TType.STRING, 'polarity', 'UTF8', None, ),  # 101
    None,  # 102
    None,  # 103
    None,  # 104
    None,  # 105
    None,  # 106
    None,  # 107
    None,  # 108
    None,  # 109
    None,  # 110
    None,  # 111
    None,  # 112
    None,  # 113
    None,  # 114
    None,  # 115
    None,  # 116
    None,  # 117
    None,  # 118
    None,  # 119
    None,  # 120
    None,  # 121
    None,  # 122
    None,  # 123
    None,  # 124
    None,  # 125
    None,  # 126
    None,  # 127
    None,  # 128
    None,  # 129
    None,  # 130
    None,  # 131
    None,  # 132
    None,  # 133
    None,  # 134
    None,  # 135
    None,  # 136
    None,  # 137
    None,  # 138
    None,  # 139
    None,  # 140
    None,  # 141
    None,  # 142
    None,  # 143
    None,  # 144
    None,  # 145
    None,  # 146
    None,  # 147
    None,  # 148
    None,  # 149
    None,  # 150
    None,  # 151
    None,  # 152
    None,  # 153
    None,  # 154
    None,  # 155
    None,  # 156
    None,  # 157
    None,  # 158
    None,  # 159
    None,  # 160
    None,  # 161
    None,  # 162
    None,  # 163
    None,  # 164
    None,  # 165
    None,  # 166
    None,  # 167
    None,  # 168
    None,  # 169
    None,  # 170
    None,  # 171
    None,  # 172
    None,  # 173
    None,  # 174
    None,  # 175
    None,  # 176
    None,  # 177
    None,  # 178
    None,  # 179
    None,  # 180
    None,  # 181
    None,  # 182
    None,  # 183
    None,  # 184
    None,  # 185
    None,  # 186
    None,  # 187
    None,  # 188
    None,  # 189
    None,  # 190
    None,  # 191
    None,  # 192
    None,  # 193
    None,  # 194
    None,  # 195
    None,  # 196
    None,  # 197
    None,  # 198
    None,  # 199
    (200, TType.DOUBLE, 'confidence', None, None, ),  # 200
    None,  # 201
    None,  # 202
    None,  # 203
    None,  # 204
    None,  # 205
    None,  # 206
    None,  # 207
    None,  # 208
    None,  # 209
    None,  # 210
    None,  # 211
    None,  # 212
    None,  # 213
    None,  # 214
    None,  # 215
    None,  # 216
    None,  # 217
    None,  # 218
    None,  # 219
    None,  # 220
    None,  # 221
    None,  # 222
    None,  # 223
    None,  # 224
    None,  # 225
    None,  # 226
    None,  # 227
    None,  # 228
    None,  # 229
    None,  # 230
    None,  # 231
    None,  # 232
    None,  # 233
    None,  # 234
    None,  # 235
    None,  # 236
    None,  # 237
    None,  # 238
    None,  # 239
    None,  # 240
    None,  # 241
    None,  # 242
    None,  # 243
    None,  # 244
    None,  # 245
    None,  # 246
    None,  # 247
    None,  # 248
    None,  # 249
    None,  # 250
    None,  # 251
    None,  # 252
    None,  # 253
    None,  # 254
    None,  # 255
    None,  # 256
    None,  # 257
    None,  # 258
    None,  # 259
    None,  # 260
    None,  # 261
    None,  # 262
    None,  # 263
    None,  # 264
    None,  # 265
    None,  # 266
    None,  # 267
    None,  # 268
    None,  # 269
    None,  # 270
    None,  # 271
    None,  # 272
    None,  # 273
    None,  # 274
    None,  # 275
    None,  # 276
    None,  # 277
    None,  # 278
    None,  # 279
    None,  # 280
    None,  # 281
    None,  # 282
    None,  # 283
    None,  # 284
    None,  # 285
    None,  # 286
    None,  # 287
    None,  # 288
    None,  # 289
    None,  # 290
    None,  # 291
    None,  # 292
    None,  # 293
    None,  # 294
    None,  # 295
    None,  # 296
    None,  # 297
    None,  # 298
    None,  # 299
    (300, TType.LIST, 'propertyList', (TType.STRUCT, [concrete.property.ttypes.Property, None], False), None, ),  # 300
)
all_structs.append(SituationSet)
SituationSet.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'uuid', [concrete.uuid.ttypes.UUID, None], None, ),  # 1
    (2, TType.STRUCT, 'metadata', [concrete.metadata.ttypes.AnnotationMetadata, None], None, ),  # 2
    (3, TType.LIST, 'situationList', (TType.STRUCT, [Situation, None], False), None, ),  # 3
    (4, TType.LIST, 'linkingList', (TType.STRUCT, [concrete.linking.ttypes.Linking, None], False), None, ),  # 4
)
all_structs.append(MentionArgument)
MentionArgument.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'role', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'entityMentionId', [concrete.uuid.ttypes.UUID, None], None, ),  # 2
    (3, TType.STRUCT, 'situationMentionId', [concrete.uuid.ttypes.UUID, None], None, ),  # 3
    (4, TType.STRUCT, 'tokens', [concrete.structure.ttypes.TokenRefSequence, None], None, ),  # 4
    (5, TType.DOUBLE, 'confidence', None, None, ),  # 5
    (6, TType.LIST, 'propertyList', (TType.STRUCT, [concrete.property.ttypes.Property, None], False), None, ),  # 6
)
all_structs.append(SituationMention)
SituationMention.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'uuid', [concrete.uuid.ttypes.UUID, None], None, ),  # 1
    (2, TType.STRING, 'text', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'situationType', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'argumentList', (TType.STRUCT, [MentionArgument, None], False), None, ),  # 4
    (5, TType.STRING, 'id', 'UTF8', None, ),  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    (50, TType.STRING, 'situationKind', 'UTF8', None, ),  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    (100, TType.DOUBLE, 'intensity', None, None, ),  # 100
    (101, TType.STRING, 'polarity', 'UTF8', None, ),  # 101
    None,  # 102
    None,  # 103
    None,  # 104
    None,  # 105
    None,  # 106
    None,  # 107
    None,  # 108
    None,  # 109
    None,  # 110
    None,  # 111
    None,  # 112
    None,  # 113
    None,  # 114
    None,  # 115
    None,  # 116
    None,  # 117
    None,  # 118
    None,  # 119
    None,  # 120
    None,  # 121
    None,  # 122
    None,  # 123
    None,  # 124
    None,  # 125
    None,  # 126
    None,  # 127
    None,  # 128
    None,  # 129
    None,  # 130
    None,  # 131
    None,  # 132
    None,  # 133
    None,  # 134
    None,  # 135
    None,  # 136
    None,  # 137
    None,  # 138
    None,  # 139
    None,  # 140
    None,  # 141
    None,  # 142
    None,  # 143
    None,  # 144
    None,  # 145
    None,  # 146
    None,  # 147
    None,  # 148
    None,  # 149
    (150, TType.STRUCT, 'tokens', [concrete.structure.ttypes.TokenRefSequence, None], None, ),  # 150
    None,  # 151
    None,  # 152
    None,  # 153
    None,  # 154
    None,  # 155
    None,  # 156
    None,  # 157
    None,  # 158
    None,  # 159
    None,  # 160
    None,  # 161
    None,  # 162
    None,  # 163
    None,  # 164
    None,  # 165
    None,  # 166
    None,  # 167
    None,  # 168
    None,  # 169
    None,  # 170
    None,  # 171
    None,  # 172
    None,  # 173
    None,  # 174
    None,  # 175
    None,  # 176
    None,  # 177
    None,  # 178
    None,  # 179
    None,  # 180
    None,  # 181
    None,  # 182
    None,  # 183
    None,  # 184
    None,  # 185
    None,  # 186
    None,  # 187
    None,  # 188
    None,  # 189
    None,  # 190
    None,  # 191
    None,  # 192
    None,  # 193
    None,  # 194
    None,  # 195
    None,  # 196
    None,  # 197
    None,  # 198
    None,  # 199
    (200, TType.DOUBLE, 'confidence', None, None, ),  # 200
    None,  # 201
    None,  # 202
    None,  # 203
    None,  # 204
    None,  # 205
    None,  # 206
    None,  # 207
    None,  # 208
    None,  # 209
    None,  # 210
    None,  # 211
    None,  # 212
    None,  # 213
    None,  # 214
    None,  # 215
    None,  # 216
    None,  # 217
    None,  # 218
    None,  # 219
    None,  # 220
    None,  # 221
    None,  # 222
    None,  # 223
    None,  # 224
    None,  # 225
    None,  # 226
    None,  # 227
    None,  # 228
    None,  # 229
    None,  # 230
    None,  # 231
    None,  # 232
    None,  # 233
    None,  # 234
    None,  # 235
    None,  # 236
    None,  # 237
    None,  # 238
    None,  # 239
    None,  # 240
    None,  # 241
    None,  # 242
    None,  # 243
    None,  # 244
    None,  # 245
    None,  # 246
    None,  # 247
    None,  # 248
    None,  # 249
    None,  # 250
    None,  # 251
    None,  # 252
    None,  # 253
    None,  # 254
    None,  # 255
    None,  # 256
    None,  # 257
    None,  # 258
    None,  # 259
    None,  # 260
    None,  # 261
    None,  # 262
    None,  # 263
    None,  # 264
    None,  # 265
    None,  # 266
    None,  # 267
    None,  # 268
    None,  # 269
    None,  # 270
    None,  # 271
    None,  # 272
    None,  # 273
    None,  # 274
    None,  # 275
    None,  # 276
    None,  # 277
    None,  # 278
    None,  # 279
    None,  # 280
    None,  # 281
    None,  # 282
    None,  # 283
    None,  # 284
    None,  # 285
    None,  # 286
    None,  # 287
    None,  # 288
    None,  # 289
    None,  # 290
    None,  # 291
    None,  # 292
    None,  # 293
    None,  # 294
    None,  # 295
    None,  # 296
    None,  # 297
    None,  # 298
    None,  # 299
    (300, TType.LIST, 'propertyList', (TType.STRUCT, [concrete.property.ttypes.Property, None], False), None, ),  # 300
)
all_structs.append(SituationMentionSet)
SituationMentionSet.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'uuid', [concrete.uuid.ttypes.UUID, None], None, ),  # 1
    (2, TType.STRUCT, 'metadata', [concrete.metadata.ttypes.AnnotationMetadata, None], None, ),  # 2
    (3, TType.LIST, 'mentionList', (TType.STRUCT, [SituationMention, None], False), None, ),  # 3
    (4, TType.LIST, 'linkingList', (TType.STRUCT, [concrete.linking.ttypes.Linking, None], False), None, ),  # 4
)
fix_spec(all_structs)
del all_structs
