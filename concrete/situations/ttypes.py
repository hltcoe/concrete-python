# -*- coding: utf-8 -*-
#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style,utf8strings,coding=utf-8
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import concrete.structure.ttypes
import concrete.metadata.ttypes
import concrete.uuid.ttypes
import concrete.linking.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class Property(object):
  """
  Attached to Arguments to support situations where
  a 'participant' has more than one 'property' (in BinarySRL terms),
  whereas Arguments notionally only support one Role.

  Attributes:
   - value: The required value of the property.
   - metadata: Metadata to support this particular property object.
   - polarity: This value is typically boolean, 0.0 or 1.0, but we use a
  float in order to potentially capture cases where an annotator is
  highly confident that the value is underspecified, via a value of
  0.5.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'value', None, None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.DOUBLE, 'polarity', None, None, ), # 3
  )

  def __init__(self, value=None, metadata=None, polarity=None,):
    self.value = value
    self.metadata = metadata
    self.polarity = polarity

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.value = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.polarity = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Property')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 1)
      oprot.writeString(self.value.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.polarity is not None:
      oprot.writeFieldBegin('polarity', TType.DOUBLE, 3)
      oprot.writeDouble(self.polarity)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.value is None:
      raise TProtocol.TProtocolException(message='Required field value is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.polarity)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Argument(object):
  """
  A situation argument, consisting of an argument role and a value.
  Argument values may be Entities or Situations.

  Attributes:
   - role: The relationship between this argument and the situation that
  owns it. The roles that a situation's arguments can take
  depend on the type of the situation (including subtype
  information, such as event_type).
   - entityId: A pointer to the value of this argument, if it is explicitly
  encoded as an Entity.
   - situationId: A pointer to the value of this argument, if it is a situation.
   - propertyList: For the BinarySRL task, there may be situations
  where more than one property is attached to a single
  participant. A list of these properties can be stored in this field.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role', None, None, ), # 1
    (2, TType.STRUCT, 'entityId', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'situationId', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 3
    (4, TType.LIST, 'propertyList', (TType.STRUCT,(Property, Property.thrift_spec)), None, ), # 4
  )

  def __init__(self, role=None, entityId=None, situationId=None, propertyList=None,):
    self.role = role
    self.entityId = entityId
    self.situationId = situationId
    self.propertyList = propertyList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.entityId = concrete.uuid.ttypes.UUID()
          self.entityId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.situationId = concrete.uuid.ttypes.UUID()
          self.situationId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.propertyList = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = Property()
            _elem5.read(iprot)
            self.propertyList.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Argument')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 1)
      oprot.writeString(self.role.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRUCT, 2)
      self.entityId.write(oprot)
      oprot.writeFieldEnd()
    if self.situationId is not None:
      oprot.writeFieldBegin('situationId', TType.STRUCT, 3)
      self.situationId.write(oprot)
      oprot.writeFieldEnd()
    if self.propertyList is not None:
      oprot.writeFieldBegin('propertyList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.propertyList))
      for iter6 in self.propertyList:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role)
    value = (value * 31) ^ hash(self.entityId)
    value = (value * 31) ^ hash(self.situationId)
    value = (value * 31) ^ hash(self.propertyList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Justification(object):
  """
  Attributes:
   - justificationType: An enumerated value used to describe the way in which the
  justification's mention provides supporting evidence for the
  situation.
   - mentionId: A pointer to the SituationMention itself.
   - tokenRefSeqList: An optional list of pointers to tokens that are (especially)
  relevant to the way in which this mention provides
  justification for the situation. It is left up to individual
  analytics to decide what tokens (if any) they wish to include
  in this field.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'justificationType', None, None, ), # 1
    (2, TType.STRUCT, 'mentionId', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 2
    (3, TType.LIST, 'tokenRefSeqList', (TType.STRUCT,(concrete.structure.ttypes.TokenRefSequence, concrete.structure.ttypes.TokenRefSequence.thrift_spec)), None, ), # 3
  )

  def __init__(self, justificationType=None, mentionId=None, tokenRefSeqList=None,):
    self.justificationType = justificationType
    self.mentionId = mentionId
    self.tokenRefSeqList = tokenRefSeqList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.justificationType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.mentionId = concrete.uuid.ttypes.UUID()
          self.mentionId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.tokenRefSeqList = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = concrete.structure.ttypes.TokenRefSequence()
            _elem12.read(iprot)
            self.tokenRefSeqList.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Justification')
    if self.justificationType is not None:
      oprot.writeFieldBegin('justificationType', TType.STRING, 1)
      oprot.writeString(self.justificationType.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.mentionId is not None:
      oprot.writeFieldBegin('mentionId', TType.STRUCT, 2)
      self.mentionId.write(oprot)
      oprot.writeFieldEnd()
    if self.tokenRefSeqList is not None:
      oprot.writeFieldBegin('tokenRefSeqList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.tokenRefSeqList))
      for iter13 in self.tokenRefSeqList:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.mentionId is None:
      raise TProtocol.TProtocolException(message='Required field mentionId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.justificationType)
    value = (value * 31) ^ hash(self.mentionId)
    value = (value * 31) ^ hash(self.tokenRefSeqList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimeML(object):
  """
  A wrapper for various TimeML annotations.

  Attributes:
   - timeMLClass: The TimeML class for situations representing TimeML events
   - timeMLTense: The TimeML tense for situations representing TimeML events
   - timeMLAspect: The TimeML aspect for situations representing TimeML events
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'timeMLClass', None, None, ), # 1
    (2, TType.STRING, 'timeMLTense', None, None, ), # 2
    (3, TType.STRING, 'timeMLAspect', None, None, ), # 3
  )

  def __init__(self, timeMLClass=None, timeMLTense=None, timeMLAspect=None,):
    self.timeMLClass = timeMLClass
    self.timeMLTense = timeMLTense
    self.timeMLAspect = timeMLAspect

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.timeMLClass = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timeMLTense = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timeMLAspect = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimeML')
    if self.timeMLClass is not None:
      oprot.writeFieldBegin('timeMLClass', TType.STRING, 1)
      oprot.writeString(self.timeMLClass.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.timeMLTense is not None:
      oprot.writeFieldBegin('timeMLTense', TType.STRING, 2)
      oprot.writeString(self.timeMLTense.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.timeMLAspect is not None:
      oprot.writeFieldBegin('timeMLAspect', TType.STRING, 3)
      oprot.writeString(self.timeMLAspect.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.timeMLClass)
    value = (value * 31) ^ hash(self.timeMLTense)
    value = (value * 31) ^ hash(self.timeMLAspect)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Situation(object):
  """
  A single situation, along with pointers to situation mentions that
  provide evidence for the situation. "Situations" include events,
  relations, facts, sentiments, and beliefs. Each situation has a
  core type (such as EVENT or SENTIMENT), along with an optional
  subtype based on its core type (e.g., event_type=CONTACT_MEET), and
  a set of zero or more unordered arguments.

  This struct may be used for a variety of "processed" Situations such
  as (but not limited to):
  - SituationMentions which have been collapsed into a coreferential cluster
  - Situations which are inferred and not directly supported by a textual mention

  Attributes:
   - uuid: Unique identifier for this situation.
   - situationType: The core type of this situation (eg EVENT or SENTIMENT),
  or a coarse grain situation type.
   - situationKind: A fine grain situation type that specifically describes the
  situation based on situationType above. It allows for more
  detailed description of the situation.

  Some examples:

  if situationType == EVENT, the event type for the situation
  if situationType == STATE, the state type
  if situationType == TEMPORAL_FACT, the temporal fact type

  For Propbank, this field should be the predicate lemma and id,
  e.g. "strike.02". For FrameNet, this should be the frame name,
  e.g. "Commerce_buy".

  Different and more varied situationTypes may be added
  in the future.
   - argumentList: The arguments for this situation. Each argument consists of a
  role and a value. It is possible for an situation to have
  multiple arguments with the same role. Arguments are
  unordered.
   - mentionIdList: Ids of the mentions of this situation in a communication
  (type=SituationMention)
   - justificationList: An list of pointers to SituationMentions that provide
  justification for this situation. These mentions may be either
  direct mentions of the situation, or indirect evidence.
   - timeML: A wrapper for TimeML annotations.
   - intensity: An "intensity" rating for this situation, typically ranging from
  0-1. In the case of SENTIMENT situations, this is used to record
  the intensity of the sentiment.
   - polarity: The polarity of this situation. In the case of SENTIMENT
  situations, this is used to record the polarity of the
  sentiment.
   - confidence: A confidence score for this individual situation. You can also
  set a confidence score for an entire SituationSet using the
  SituationSet's metadata.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRING, 'situationType', None, None, ), # 2
    (3, TType.LIST, 'argumentList', (TType.STRUCT,(Argument, Argument.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'mentionIdList', (TType.STRUCT,(concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'justificationList', (TType.STRUCT,(Justification, Justification.thrift_spec)), None, ), # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    None, # 10
    None, # 11
    None, # 12
    None, # 13
    None, # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    None, # 20
    None, # 21
    None, # 22
    None, # 23
    None, # 24
    None, # 25
    None, # 26
    None, # 27
    None, # 28
    None, # 29
    None, # 30
    None, # 31
    None, # 32
    None, # 33
    None, # 34
    None, # 35
    None, # 36
    None, # 37
    None, # 38
    None, # 39
    None, # 40
    None, # 41
    None, # 42
    None, # 43
    None, # 44
    None, # 45
    None, # 46
    None, # 47
    None, # 48
    None, # 49
    (50, TType.STRING, 'situationKind', None, None, ), # 50
    None, # 51
    None, # 52
    None, # 53
    (54, TType.STRUCT, 'timeML', (TimeML, TimeML.thrift_spec), None, ), # 54
    None, # 55
    None, # 56
    None, # 57
    None, # 58
    None, # 59
    None, # 60
    None, # 61
    None, # 62
    None, # 63
    None, # 64
    None, # 65
    None, # 66
    None, # 67
    None, # 68
    None, # 69
    None, # 70
    None, # 71
    None, # 72
    None, # 73
    None, # 74
    None, # 75
    None, # 76
    None, # 77
    None, # 78
    None, # 79
    None, # 80
    None, # 81
    None, # 82
    None, # 83
    None, # 84
    None, # 85
    None, # 86
    None, # 87
    None, # 88
    None, # 89
    None, # 90
    None, # 91
    None, # 92
    None, # 93
    None, # 94
    None, # 95
    None, # 96
    None, # 97
    None, # 98
    None, # 99
    (100, TType.DOUBLE, 'intensity', None, None, ), # 100
    (101, TType.STRING, 'polarity', None, None, ), # 101
    None, # 102
    None, # 103
    None, # 104
    None, # 105
    None, # 106
    None, # 107
    None, # 108
    None, # 109
    None, # 110
    None, # 111
    None, # 112
    None, # 113
    None, # 114
    None, # 115
    None, # 116
    None, # 117
    None, # 118
    None, # 119
    None, # 120
    None, # 121
    None, # 122
    None, # 123
    None, # 124
    None, # 125
    None, # 126
    None, # 127
    None, # 128
    None, # 129
    None, # 130
    None, # 131
    None, # 132
    None, # 133
    None, # 134
    None, # 135
    None, # 136
    None, # 137
    None, # 138
    None, # 139
    None, # 140
    None, # 141
    None, # 142
    None, # 143
    None, # 144
    None, # 145
    None, # 146
    None, # 147
    None, # 148
    None, # 149
    None, # 150
    None, # 151
    None, # 152
    None, # 153
    None, # 154
    None, # 155
    None, # 156
    None, # 157
    None, # 158
    None, # 159
    None, # 160
    None, # 161
    None, # 162
    None, # 163
    None, # 164
    None, # 165
    None, # 166
    None, # 167
    None, # 168
    None, # 169
    None, # 170
    None, # 171
    None, # 172
    None, # 173
    None, # 174
    None, # 175
    None, # 176
    None, # 177
    None, # 178
    None, # 179
    None, # 180
    None, # 181
    None, # 182
    None, # 183
    None, # 184
    None, # 185
    None, # 186
    None, # 187
    None, # 188
    None, # 189
    None, # 190
    None, # 191
    None, # 192
    None, # 193
    None, # 194
    None, # 195
    None, # 196
    None, # 197
    None, # 198
    None, # 199
    (200, TType.DOUBLE, 'confidence', None, None, ), # 200
  )

  def __init__(self, uuid=None, situationType=None, situationKind=None, argumentList=None, mentionIdList=None, justificationList=None, timeML=None, intensity=None, polarity=None, confidence=None,):
    self.uuid = uuid
    self.situationType = situationType
    self.situationKind = situationKind
    self.argumentList = argumentList
    self.mentionIdList = mentionIdList
    self.justificationList = justificationList
    self.timeML = timeML
    self.intensity = intensity
    self.polarity = polarity
    self.confidence = confidence

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.situationType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 50:
        if ftype == TType.STRING:
          self.situationKind = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.argumentList = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = Argument()
            _elem19.read(iprot)
            self.argumentList.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.mentionIdList = []
          (_etype23, _size20) = iprot.readListBegin()
          for _i24 in xrange(_size20):
            _elem25 = concrete.uuid.ttypes.UUID()
            _elem25.read(iprot)
            self.mentionIdList.append(_elem25)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.justificationList = []
          (_etype29, _size26) = iprot.readListBegin()
          for _i30 in xrange(_size26):
            _elem31 = Justification()
            _elem31.read(iprot)
            self.justificationList.append(_elem31)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 54:
        if ftype == TType.STRUCT:
          self.timeML = TimeML()
          self.timeML.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 100:
        if ftype == TType.DOUBLE:
          self.intensity = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 101:
        if ftype == TType.STRING:
          self.polarity = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 200:
        if ftype == TType.DOUBLE:
          self.confidence = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Situation')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.situationType is not None:
      oprot.writeFieldBegin('situationType', TType.STRING, 2)
      oprot.writeString(self.situationType.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.argumentList is not None:
      oprot.writeFieldBegin('argumentList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.argumentList))
      for iter32 in self.argumentList:
        iter32.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.mentionIdList is not None:
      oprot.writeFieldBegin('mentionIdList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.mentionIdList))
      for iter33 in self.mentionIdList:
        iter33.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.justificationList is not None:
      oprot.writeFieldBegin('justificationList', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.justificationList))
      for iter34 in self.justificationList:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.situationKind is not None:
      oprot.writeFieldBegin('situationKind', TType.STRING, 50)
      oprot.writeString(self.situationKind.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.timeML is not None:
      oprot.writeFieldBegin('timeML', TType.STRUCT, 54)
      self.timeML.write(oprot)
      oprot.writeFieldEnd()
    if self.intensity is not None:
      oprot.writeFieldBegin('intensity', TType.DOUBLE, 100)
      oprot.writeDouble(self.intensity)
      oprot.writeFieldEnd()
    if self.polarity is not None:
      oprot.writeFieldBegin('polarity', TType.STRING, 101)
      oprot.writeString(self.polarity.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.confidence is not None:
      oprot.writeFieldBegin('confidence', TType.DOUBLE, 200)
      oprot.writeDouble(self.confidence)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.situationType is None:
      raise TProtocol.TProtocolException(message='Required field situationType is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.situationType)
    value = (value * 31) ^ hash(self.situationKind)
    value = (value * 31) ^ hash(self.argumentList)
    value = (value * 31) ^ hash(self.mentionIdList)
    value = (value * 31) ^ hash(self.justificationList)
    value = (value * 31) ^ hash(self.timeML)
    value = (value * 31) ^ hash(self.intensity)
    value = (value * 31) ^ hash(self.polarity)
    value = (value * 31) ^ hash(self.confidence)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SituationSet(object):
  """
  A theory about the set of situations that are present in a
  message. See also: Situation

  Attributes:
   - uuid: Unique identifier for this set.
   - metadata: Information about where this set came from.
   - situationList: List of mentions in this set.
   - linkingList: Entity linking annotations associated with this SituationSet.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.LIST, 'situationList', (TType.STRUCT,(Situation, Situation.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'linkingList', (TType.STRUCT,(concrete.linking.ttypes.Linking, concrete.linking.ttypes.Linking.thrift_spec)), None, ), # 4
  )

  def __init__(self, uuid=None, metadata=None, situationList=None, linkingList=None,):
    self.uuid = uuid
    self.metadata = metadata
    self.situationList = situationList
    self.linkingList = linkingList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.situationList = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = Situation()
            _elem40.read(iprot)
            self.situationList.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.linkingList = []
          (_etype44, _size41) = iprot.readListBegin()
          for _i45 in xrange(_size41):
            _elem46 = concrete.linking.ttypes.Linking()
            _elem46.read(iprot)
            self.linkingList.append(_elem46)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SituationSet')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.situationList is not None:
      oprot.writeFieldBegin('situationList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.situationList))
      for iter47 in self.situationList:
        iter47.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.linkingList is not None:
      oprot.writeFieldBegin('linkingList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.linkingList))
      for iter48 in self.linkingList:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.situationList is None:
      raise TProtocol.TProtocolException(message='Required field situationList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.situationList)
    value = (value * 31) ^ hash(self.linkingList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MentionArgument(object):
  """
  A "concrete" argument, that may be used by SituationMentions or EntityMentions
  to avoid conflicts where abstract Arguments were being used to support concrete Mentions.

  Attributes:
   - role: The relationship between this argument and the situation that
  owns it. The roles that a situation's arguments can take
  depend on the type of the situation (including subtype
  information, such as event_type).
   - entityMentionId: A pointer to the value of an EntityMention, if this is being used to support
  an EntityMention.
   - situationMentionId: A pointer to the value of this argument, if it is a SituationMention.
   - tokens: The location of this MentionArgument in the Communication.
  If this MentionArgument can be identified in a document using an
  EntityMention or SituationMention, then UUID references to those
  types should be preferred and this field left as null.
   - constituent: An alternative way to specify the same thing as tokens.
   - confidence: Confidence of this argument belonging to its SituationMention
   - propertyList: For the BinarySRL task, there may be situations
  where more than one property is attached to a single
  participant. A list of these properties can be stored in this field.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role', None, None, ), # 1
    (2, TType.STRUCT, 'entityMentionId', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'situationMentionId', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'tokens', (concrete.structure.ttypes.TokenRefSequence, concrete.structure.ttypes.TokenRefSequence.thrift_spec), None, ), # 4
    (5, TType.DOUBLE, 'confidence', None, None, ), # 5
    (6, TType.LIST, 'propertyList', (TType.STRUCT,(Property, Property.thrift_spec)), None, ), # 6
    (7, TType.STRUCT, 'constituent', (concrete.structure.ttypes.ConstituentRef, concrete.structure.ttypes.ConstituentRef.thrift_spec), None, ), # 7
  )

  def __init__(self, role=None, entityMentionId=None, situationMentionId=None, tokens=None, constituent=None, confidence=None, propertyList=None,):
    self.role = role
    self.entityMentionId = entityMentionId
    self.situationMentionId = situationMentionId
    self.tokens = tokens
    self.constituent = constituent
    self.confidence = confidence
    self.propertyList = propertyList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.entityMentionId = concrete.uuid.ttypes.UUID()
          self.entityMentionId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.situationMentionId = concrete.uuid.ttypes.UUID()
          self.situationMentionId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.tokens = concrete.structure.ttypes.TokenRefSequence()
          self.tokens.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.constituent = concrete.structure.ttypes.ConstituentRef()
          self.constituent.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.confidence = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.propertyList = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = Property()
            _elem54.read(iprot)
            self.propertyList.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MentionArgument')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 1)
      oprot.writeString(self.role.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.entityMentionId is not None:
      oprot.writeFieldBegin('entityMentionId', TType.STRUCT, 2)
      self.entityMentionId.write(oprot)
      oprot.writeFieldEnd()
    if self.situationMentionId is not None:
      oprot.writeFieldBegin('situationMentionId', TType.STRUCT, 3)
      self.situationMentionId.write(oprot)
      oprot.writeFieldEnd()
    if self.tokens is not None:
      oprot.writeFieldBegin('tokens', TType.STRUCT, 4)
      self.tokens.write(oprot)
      oprot.writeFieldEnd()
    if self.confidence is not None:
      oprot.writeFieldBegin('confidence', TType.DOUBLE, 5)
      oprot.writeDouble(self.confidence)
      oprot.writeFieldEnd()
    if self.propertyList is not None:
      oprot.writeFieldBegin('propertyList', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.propertyList))
      for iter55 in self.propertyList:
        iter55.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.constituent is not None:
      oprot.writeFieldBegin('constituent', TType.STRUCT, 7)
      self.constituent.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role)
    value = (value * 31) ^ hash(self.entityMentionId)
    value = (value * 31) ^ hash(self.situationMentionId)
    value = (value * 31) ^ hash(self.tokens)
    value = (value * 31) ^ hash(self.constituent)
    value = (value * 31) ^ hash(self.confidence)
    value = (value * 31) ^ hash(self.propertyList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SituationMention(object):
  """
  A concrete mention of a situation, where "situations" include
  events, relations, facts, sentiments, and beliefs. Each situation
  has a core type (such as EVENT or SENTIMENT), along with an
  optional subtype based on its core type (e.g.,
  event_type=CONTACT_MEET), and a set of zero or more unordered
  arguments.

  This struct should be used for most types of SRL labelings
  (e.g. Propbank and FrameNet) because they are grounded in text.

  Attributes:
   - uuid: Unique identifier for this situation.
   - text: The text content of this situation mention. This field is
  often redundant with the 'tokens' field, and may not
  be generated by all analytics.
   - situationType: The core type of this situation (eg EVENT or SENTIMENT),
  or a coarse grain situation type.
   - situationKind: A fine grain situation type that specifically describes the
  situation mention based on situationType above. It allows for
  more detailed description of the situation mention.

  Some examples:

  if situationType == EVENT, the event type for the sit. mention
  if situationType == STATE, the state type for this sit. mention

  For Propbank, this field should be the predicate lemma and id,
  e.g. "strike.02". For FrameNet, this should be the frame name,
  e.g. "Commerce_buy".

  Different and more varied situationTypes may be added
  in the future.
   - argumentList: The arguments for this situation mention. Each argument
  consists of a role and a value. It is possible for an situation
  to have multiple arguments with the same role. Arguments are
  unordered.
   - intensity: An "intensity" rating for the situation, typically ranging from
  0-1. In the case of SENTIMENT situations, this is used to record
  the intensity of the sentiment.
   - polarity: The polarity of this situation. In the case of SENTIMENT
  situations, this is used to record the polarity of the
  sentiment.
   - tokens: An optional pointer to tokens that are (especially)
  relevant to this situation mention. It is left up to individual
  analytics to decide what tokens (if any) they wish to include in
  this field. In particular, it is not specified whether the
  arguments' tokens should be included.
   - constituent: An alternative way to specify the same thing as tokens.
   - confidence: A confidence score for this individual situation mention. You
  can also set a confidence score for an entire SituationMentionSet
  using the SituationMentionSet's metadata.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRING, 'text', None, None, ), # 2
    (3, TType.STRING, 'situationType', None, None, ), # 3
    (4, TType.LIST, 'argumentList', (TType.STRUCT,(MentionArgument, MentionArgument.thrift_spec)), None, ), # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    None, # 10
    None, # 11
    None, # 12
    None, # 13
    None, # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    None, # 20
    None, # 21
    None, # 22
    None, # 23
    None, # 24
    None, # 25
    None, # 26
    None, # 27
    None, # 28
    None, # 29
    None, # 30
    None, # 31
    None, # 32
    None, # 33
    None, # 34
    None, # 35
    None, # 36
    None, # 37
    None, # 38
    None, # 39
    None, # 40
    None, # 41
    None, # 42
    None, # 43
    None, # 44
    None, # 45
    None, # 46
    None, # 47
    None, # 48
    None, # 49
    (50, TType.STRING, 'situationKind', None, None, ), # 50
    None, # 51
    None, # 52
    None, # 53
    None, # 54
    None, # 55
    None, # 56
    None, # 57
    None, # 58
    None, # 59
    None, # 60
    None, # 61
    None, # 62
    None, # 63
    None, # 64
    None, # 65
    None, # 66
    None, # 67
    None, # 68
    None, # 69
    None, # 70
    None, # 71
    None, # 72
    None, # 73
    None, # 74
    None, # 75
    None, # 76
    None, # 77
    None, # 78
    None, # 79
    None, # 80
    None, # 81
    None, # 82
    None, # 83
    None, # 84
    None, # 85
    None, # 86
    None, # 87
    None, # 88
    None, # 89
    None, # 90
    None, # 91
    None, # 92
    None, # 93
    None, # 94
    None, # 95
    None, # 96
    None, # 97
    None, # 98
    None, # 99
    (100, TType.DOUBLE, 'intensity', None, None, ), # 100
    (101, TType.STRING, 'polarity', None, None, ), # 101
    None, # 102
    None, # 103
    None, # 104
    None, # 105
    None, # 106
    None, # 107
    None, # 108
    None, # 109
    None, # 110
    None, # 111
    None, # 112
    None, # 113
    None, # 114
    None, # 115
    None, # 116
    None, # 117
    None, # 118
    None, # 119
    None, # 120
    None, # 121
    None, # 122
    None, # 123
    None, # 124
    None, # 125
    None, # 126
    None, # 127
    None, # 128
    None, # 129
    None, # 130
    None, # 131
    None, # 132
    None, # 133
    None, # 134
    None, # 135
    None, # 136
    None, # 137
    None, # 138
    None, # 139
    None, # 140
    None, # 141
    None, # 142
    None, # 143
    None, # 144
    None, # 145
    None, # 146
    None, # 147
    None, # 148
    None, # 149
    (150, TType.STRUCT, 'tokens', (concrete.structure.ttypes.TokenRefSequence, concrete.structure.ttypes.TokenRefSequence.thrift_spec), None, ), # 150
    (151, TType.STRUCT, 'constituent', (concrete.structure.ttypes.ConstituentRef, concrete.structure.ttypes.ConstituentRef.thrift_spec), None, ), # 151
    None, # 152
    None, # 153
    None, # 154
    None, # 155
    None, # 156
    None, # 157
    None, # 158
    None, # 159
    None, # 160
    None, # 161
    None, # 162
    None, # 163
    None, # 164
    None, # 165
    None, # 166
    None, # 167
    None, # 168
    None, # 169
    None, # 170
    None, # 171
    None, # 172
    None, # 173
    None, # 174
    None, # 175
    None, # 176
    None, # 177
    None, # 178
    None, # 179
    None, # 180
    None, # 181
    None, # 182
    None, # 183
    None, # 184
    None, # 185
    None, # 186
    None, # 187
    None, # 188
    None, # 189
    None, # 190
    None, # 191
    None, # 192
    None, # 193
    None, # 194
    None, # 195
    None, # 196
    None, # 197
    None, # 198
    None, # 199
    (200, TType.DOUBLE, 'confidence', None, None, ), # 200
  )

  def __init__(self, uuid=None, text=None, situationType=None, situationKind=None, argumentList=None, intensity=None, polarity=None, tokens=None, constituent=None, confidence=None,):
    self.uuid = uuid
    self.text = text
    self.situationType = situationType
    self.situationKind = situationKind
    self.argumentList = argumentList
    self.intensity = intensity
    self.polarity = polarity
    self.tokens = tokens
    self.constituent = constituent
    self.confidence = confidence

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.text = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.situationType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 50:
        if ftype == TType.STRING:
          self.situationKind = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.argumentList = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = MentionArgument()
            _elem61.read(iprot)
            self.argumentList.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 100:
        if ftype == TType.DOUBLE:
          self.intensity = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 101:
        if ftype == TType.STRING:
          self.polarity = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 150:
        if ftype == TType.STRUCT:
          self.tokens = concrete.structure.ttypes.TokenRefSequence()
          self.tokens.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 151:
        if ftype == TType.STRUCT:
          self.constituent = concrete.structure.ttypes.ConstituentRef()
          self.constituent.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 200:
        if ftype == TType.DOUBLE:
          self.confidence = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SituationMention')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 2)
      oprot.writeString(self.text.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.situationType is not None:
      oprot.writeFieldBegin('situationType', TType.STRING, 3)
      oprot.writeString(self.situationType.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.argumentList is not None:
      oprot.writeFieldBegin('argumentList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.argumentList))
      for iter62 in self.argumentList:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.situationKind is not None:
      oprot.writeFieldBegin('situationKind', TType.STRING, 50)
      oprot.writeString(self.situationKind.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.intensity is not None:
      oprot.writeFieldBegin('intensity', TType.DOUBLE, 100)
      oprot.writeDouble(self.intensity)
      oprot.writeFieldEnd()
    if self.polarity is not None:
      oprot.writeFieldBegin('polarity', TType.STRING, 101)
      oprot.writeString(self.polarity.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.tokens is not None:
      oprot.writeFieldBegin('tokens', TType.STRUCT, 150)
      self.tokens.write(oprot)
      oprot.writeFieldEnd()
    if self.constituent is not None:
      oprot.writeFieldBegin('constituent', TType.STRUCT, 151)
      self.constituent.write(oprot)
      oprot.writeFieldEnd()
    if self.confidence is not None:
      oprot.writeFieldBegin('confidence', TType.DOUBLE, 200)
      oprot.writeDouble(self.confidence)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.argumentList is None:
      raise TProtocol.TProtocolException(message='Required field argumentList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.text)
    value = (value * 31) ^ hash(self.situationType)
    value = (value * 31) ^ hash(self.situationKind)
    value = (value * 31) ^ hash(self.argumentList)
    value = (value * 31) ^ hash(self.intensity)
    value = (value * 31) ^ hash(self.polarity)
    value = (value * 31) ^ hash(self.tokens)
    value = (value * 31) ^ hash(self.constituent)
    value = (value * 31) ^ hash(self.confidence)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SituationMentionSet(object):
  """
  A theory about the set of situation mentions that are present in a
  message. See also: SituationMention

  Attributes:
   - uuid: Unique identifier for this set.
   - metadata: Information about where this set came from.
   - mentionList: List of mentions in this set.
   - linkingList: Entity linking annotations associated with this SituationMentionSet.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.LIST, 'mentionList', (TType.STRUCT,(SituationMention, SituationMention.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'linkingList', (TType.STRUCT,(concrete.linking.ttypes.Linking, concrete.linking.ttypes.Linking.thrift_spec)), None, ), # 4
  )

  def __init__(self, uuid=None, metadata=None, mentionList=None, linkingList=None,):
    self.uuid = uuid
    self.metadata = metadata
    self.mentionList = mentionList
    self.linkingList = linkingList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.mentionList = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = SituationMention()
            _elem68.read(iprot)
            self.mentionList.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.linkingList = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = concrete.linking.ttypes.Linking()
            _elem74.read(iprot)
            self.linkingList.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SituationMentionSet')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.mentionList is not None:
      oprot.writeFieldBegin('mentionList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.mentionList))
      for iter75 in self.mentionList:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.linkingList is not None:
      oprot.writeFieldBegin('linkingList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.linkingList))
      for iter76 in self.linkingList:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.mentionList is None:
      raise TProtocol.TProtocolException(message='Required field mentionList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.mentionList)
    value = (value * 31) ^ hash(self.linkingList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
