#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import concrete.metadata.ttypes
import concrete.spans.ttypes
import concrete.uuid.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TokenizationKind(object):
  """
  Enumerated types of Tokenizations
  """
  TOKEN_LIST = 1
  TOKEN_LATTICE = 2

  _VALUES_TO_NAMES = {
    1: "TOKEN_LIST",
    2: "TOKEN_LATTICE",
  }

  _NAMES_TO_VALUES = {
    "TOKEN_LIST": 1,
    "TOKEN_LATTICE": 2,
  }


class Token(object):
  """
  A single token (typically a word) in a communication. The exact
  definition of what counts as a token is left up to the tools that
  generate token sequences.

  Usually, each token will include at least a text string.

  Attributes:
   - tokenIndex: A 0-based tokenization-relative identifier for this token that
  represents the order that this token appears in the
  sentence. Together with the UUID for a Tokenization, this can be
  used to define pointers to specific tokens. If a Tokenization
  object contains multiple Token objects with the same id (e.g., in
  different n-best lists), then all of their other fields *must* be
  identical as well.
   - text: The text associated with this token.
  Note - we may have a destructive tokenizer (e.g., Stanford rewriting)
  and as a result, we want to maintain this field.
   - textSpan: Location of this token in this perspective's text (.text field).
  In cases where this token does not correspond directly with any
  text span in the text (such as word insertion during MT),
  this field may be given a value indicating "approximately" where
  the token comes from. A span covering the entire sentence may be
  used if no more precise value seems appropriate.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the document, but is the annotation's best
  effort at such a representation.
   - rawTextSpan: Location of this token in the original, raw text (.originalText
  field).  In cases where this token does not correspond directly
  with any text span in the original text (such as word insertion
  during MT), this field may be given a value indicating
  "approximately" where the token comes from. A span covering the
  entire sentence may be used if no more precise value seems
  appropriate.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original raw document, but is the annotation's best
  effort at such a representation.
   - audioSpan: Location of this token in the original audio.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tokenIndex', None, None, ), # 1
    (2, TType.STRING, 'text', None, None, ), # 2
    (3, TType.STRUCT, 'textSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'rawTextSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'audioSpan', (concrete.spans.ttypes.AudioSpan, concrete.spans.ttypes.AudioSpan.thrift_spec), None, ), # 5
  )

  def __init__(self, tokenIndex=None, text=None, textSpan=None, rawTextSpan=None, audioSpan=None,):
    self.tokenIndex = tokenIndex
    self.text = text
    self.textSpan = textSpan
    self.rawTextSpan = rawTextSpan
    self.audioSpan = audioSpan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tokenIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.text = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.textSpan = concrete.spans.ttypes.TextSpan()
          self.textSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.rawTextSpan = concrete.spans.ttypes.TextSpan()
          self.rawTextSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.audioSpan = concrete.spans.ttypes.AudioSpan()
          self.audioSpan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Token')
    if self.tokenIndex is not None:
      oprot.writeFieldBegin('tokenIndex', TType.I32, 1)
      oprot.writeI32(self.tokenIndex)
      oprot.writeFieldEnd()
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 2)
      oprot.writeString(self.text.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.textSpan is not None:
      oprot.writeFieldBegin('textSpan', TType.STRUCT, 3)
      self.textSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.rawTextSpan is not None:
      oprot.writeFieldBegin('rawTextSpan', TType.STRUCT, 4)
      self.rawTextSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.audioSpan is not None:
      oprot.writeFieldBegin('audioSpan', TType.STRUCT, 5)
      self.audioSpan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tokenIndex is None:
      raise TProtocol.TProtocolException(message='Required field tokenIndex is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TokenRefSequence(object):
  """
  A list of pointers to tokens that all belong to the same
  tokenization.

  Attributes:
   - tokenIndexList: The tokenization-relative identifiers for each token that is
  included in this sequence.
   - anchorTokenIndex: An optional field that can be used to describe
  the root of a sentence (if this sequence is a full sentence),
  the head of a constituent (if this sequence is a constituent),
  or some other form of "canonical" token in this sequence if,
  for instance, it is not easy to map this sequence to a another
  annotation that has a head.
   - tokenizationId: The UUID of the tokenization that contains the tokens.
   - textSpan: The text span in the main text (.text field) associated with this
  TokenRefSequence.

  NOTE: This span represents a best guess, or 'provenance': it
  cannot be guaranteed that this text span matches the _exact_ text
  of the original document, but is the annotation's best effort at
  such a representation.
   - rawTextSpan: The text span in the original text (.originalText field)
  associated with this TokenRefSequence.

  NOTE: This span represents a best guess, or 'provenance': it
  cannot be guaranteed that this text span matches the _exact_ text
  of the original raw document, but is the annotation's best effort
  at such a representation.
   - audioSpan: The audio span associated with this TokenRefSequence.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tokenIndexList', (TType.I32,None), None, ), # 1
    (2, TType.I32, 'anchorTokenIndex', None, -1, ), # 2
    (3, TType.STRUCT, 'tokenizationId', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'textSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'rawTextSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'audioSpan', (concrete.spans.ttypes.AudioSpan, concrete.spans.ttypes.AudioSpan.thrift_spec), None, ), # 6
  )

  def __init__(self, tokenIndexList=None, anchorTokenIndex=thrift_spec[2][4], tokenizationId=None, textSpan=None, rawTextSpan=None, audioSpan=None,):
    self.tokenIndexList = tokenIndexList
    self.anchorTokenIndex = anchorTokenIndex
    self.tokenizationId = tokenizationId
    self.textSpan = textSpan
    self.rawTextSpan = rawTextSpan
    self.audioSpan = audioSpan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tokenIndexList = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI32();
            self.tokenIndexList.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.anchorTokenIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.tokenizationId = concrete.uuid.ttypes.UUID()
          self.tokenizationId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.textSpan = concrete.spans.ttypes.TextSpan()
          self.textSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.rawTextSpan = concrete.spans.ttypes.TextSpan()
          self.rawTextSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.audioSpan = concrete.spans.ttypes.AudioSpan()
          self.audioSpan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TokenRefSequence')
    if self.tokenIndexList is not None:
      oprot.writeFieldBegin('tokenIndexList', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.tokenIndexList))
      for iter6 in self.tokenIndexList:
        oprot.writeI32(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.anchorTokenIndex is not None:
      oprot.writeFieldBegin('anchorTokenIndex', TType.I32, 2)
      oprot.writeI32(self.anchorTokenIndex)
      oprot.writeFieldEnd()
    if self.tokenizationId is not None:
      oprot.writeFieldBegin('tokenizationId', TType.STRUCT, 3)
      self.tokenizationId.write(oprot)
      oprot.writeFieldEnd()
    if self.textSpan is not None:
      oprot.writeFieldBegin('textSpan', TType.STRUCT, 4)
      self.textSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.rawTextSpan is not None:
      oprot.writeFieldBegin('rawTextSpan', TType.STRUCT, 5)
      self.rawTextSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.audioSpan is not None:
      oprot.writeFieldBegin('audioSpan', TType.STRUCT, 6)
      self.audioSpan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tokenIndexList is None:
      raise TProtocol.TProtocolException(message='Required field tokenIndexList is unset!')
    if self.tokenizationId is None:
      raise TProtocol.TProtocolException(message='Required field tokenizationId is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TaggedToken(object):
  """
  Attributes:
   - tokenIndex: A pointer to the token being tagged.
   - tag: A string containing the annotation.
  If the tag set you are using is not case sensitive,
  then all part of speech tags should be normalized to upper case.
   - confidence: Confidence of the annotation.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tokenIndex', None, None, ), # 1
    (2, TType.STRING, 'tag', None, None, ), # 2
    (3, TType.DOUBLE, 'confidence', None, None, ), # 3
  )

  def __init__(self, tokenIndex=None, tag=None, confidence=None,):
    self.tokenIndex = tokenIndex
    self.tag = tag
    self.confidence = confidence

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tokenIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.confidence = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaggedToken')
    if self.tokenIndex is not None:
      oprot.writeFieldBegin('tokenIndex', TType.I32, 1)
      oprot.writeI32(self.tokenIndex)
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRING, 2)
      oprot.writeString(self.tag.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.confidence is not None:
      oprot.writeFieldBegin('confidence', TType.DOUBLE, 3)
      oprot.writeDouble(self.confidence)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TokenTagging(object):
  """
  A theory about some token-level annotation.
  The TokenTagging consists of a mapping from tokens
  (using token ids) to string tags (e.g. part-of-speech tags or lemmas).

  The mapping defined by a TokenTagging may be partial --
  i.e., some tokens may not be assigned any part of speech tags.

  For lattice tokenizations, you may need to create multiple
  part-of-speech taggings (for different paths through the lattice),
  since the appropriate tag for a given token may depend on the path
  taken. For example, you might define a separate
  TokenTagging for each of the top K paths, which leaves all
  tokens that are not part of the path unlabeled.

  Currently, we use strings to encode annotations. In
  the future, we may add fields for encoding specific tag sets
  (eg treebank tags), or for adding compound tags.

  Attributes:
   - uuid: The UUID of this TokenTagging object.
   - metadata: Information about where the annotation came from.
  This should be used to tell between gold-standard annotations
  and automatically-generated theories about the data
   - taggedTokenList: The mapping from tokens to annotations.
  This may be a partial mapping.
   - taggingType: An ontology-backed string that represents the
  type of token taggings this TokenTagging object
  produces.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.LIST, 'taggedTokenList', (TType.STRUCT,(TaggedToken, TaggedToken.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'taggingType', None, None, ), # 4
  )

  def __init__(self, uuid=None, metadata=None, taggedTokenList=None, taggingType=None,):
    self.uuid = uuid
    self.metadata = metadata
    self.taggedTokenList = taggedTokenList
    self.taggingType = taggingType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.taggedTokenList = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = TaggedToken()
            _elem12.read(iprot)
            self.taggedTokenList.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.taggingType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TokenTagging')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.taggedTokenList is not None:
      oprot.writeFieldBegin('taggedTokenList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.taggedTokenList))
      for iter13 in self.taggedTokenList:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.taggingType is not None:
      oprot.writeFieldBegin('taggingType', TType.STRING, 4)
      oprot.writeString(self.taggingType.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.taggedTokenList is None:
      raise TProtocol.TProtocolException(message='Required field taggedTokenList is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Dependency(object):
  """
  A syntactic edge between two tokens in a tokenized sentence.

  Attributes:
   - gov: The governor or the head token. 0 indexed.
   - dep: The dependent token. 0 indexed.
   - edgeType: The relation that holds between gov and dep.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gov', None, -1, ), # 1
    (2, TType.I32, 'dep', None, None, ), # 2
    (3, TType.STRING, 'edgeType', None, None, ), # 3
  )

  def __init__(self, gov=thrift_spec[1][4], dep=None, edgeType=None,):
    self.gov = gov
    self.dep = dep
    self.edgeType = edgeType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gov = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.dep = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.edgeType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Dependency')
    if self.gov is not None:
      oprot.writeFieldBegin('gov', TType.I32, 1)
      oprot.writeI32(self.gov)
      oprot.writeFieldEnd()
    if self.dep is not None:
      oprot.writeFieldBegin('dep', TType.I32, 2)
      oprot.writeI32(self.dep)
      oprot.writeFieldEnd()
    if self.edgeType is not None:
      oprot.writeFieldBegin('edgeType', TType.STRING, 3)
      oprot.writeString(self.edgeType.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dep is None:
      raise TProtocol.TProtocolException(message='Required field dep is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DependencyParse(object):
  """
  Represents a dependency parse with typed edges.

  Attributes:
   - uuid
   - metadata
   - dependencyList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.LIST, 'dependencyList', (TType.STRUCT,(Dependency, Dependency.thrift_spec)), None, ), # 3
  )

  def __init__(self, uuid=None, metadata=None, dependencyList=None,):
    self.uuid = uuid
    self.metadata = metadata
    self.dependencyList = dependencyList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.dependencyList = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = Dependency()
            _elem19.read(iprot)
            self.dependencyList.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DependencyParse')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.dependencyList is not None:
      oprot.writeFieldBegin('dependencyList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.dependencyList))
      for iter20 in self.dependencyList:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.dependencyList is None:
      raise TProtocol.TProtocolException(message='Required field dependencyList is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Constituent(object):
  """
  A single parse constituent (or "phrase").

  Attributes:
   - id: A parse-relative identifier for this consistuent. Together
  with the UUID for a Parse, this can be used to define
  pointers to specific constituents.
   - tag
   - childList
   - tokenSequence: The list of pointers to the tokens dominated by this
  constituent. Typically, this field will only be defined for
  leaf constituents (i.e., constituents with no children). For
  many parsers, len(tokens) will always be either 1 (for leaf
  constituents) or 0 (for non-leaf constituents).
   - headChildIndex: The index of the head child of this constituent. I.e., the
  head child of constituent <tt>c</tt> is
  <tt>c.children[c.head_child_index]</tt>. A value of -1
  indicates that no child head was identified.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, None, ), # 1
    (2, TType.STRING, 'tag', None, None, ), # 2
    (3, TType.LIST, 'childList', (TType.I32,None), None, ), # 3
    (4, TType.STRUCT, 'tokenSequence', (TokenRefSequence, TokenRefSequence.thrift_spec), None, ), # 4
    (5, TType.I32, 'headChildIndex', None, -1, ), # 5
  )

  def __init__(self, id=None, tag=None, childList=None, tokenSequence=None, headChildIndex=thrift_spec[5][4],):
    self.id = id
    self.tag = tag
    self.childList = childList
    self.tokenSequence = tokenSequence
    self.headChildIndex = headChildIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.childList = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readI32();
            self.childList.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.tokenSequence = TokenRefSequence()
          self.tokenSequence.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.headChildIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Constituent')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRING, 2)
      oprot.writeString(self.tag.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.childList is not None:
      oprot.writeFieldBegin('childList', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.childList))
      for iter27 in self.childList:
        oprot.writeI32(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.tokenSequence is not None:
      oprot.writeFieldBegin('tokenSequence', TType.STRUCT, 4)
      self.tokenSequence.write(oprot)
      oprot.writeFieldEnd()
    if self.headChildIndex is not None:
      oprot.writeFieldBegin('headChildIndex', TType.I32, 5)
      oprot.writeI32(self.headChildIndex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.childList is None:
      raise TProtocol.TProtocolException(message='Required field childList is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Parse(object):
  """
  A theory about the syntactic parse of a sentence.

  \note If we add support for parse forests in the future, then it
  will most likely be done by adding a new field (e.g.
  "<tt>forest_root</tt>") that uses a new struct type to encode the
  forest. A "<tt>kind</tt>" field might also be added (analogous to
  <tt>Tokenization.kind</tt>) to indicate whether a parse is encoded
  using a simple tree or a parse forest.

  Attributes:
   - uuid
   - metadata
   - constituentList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.LIST, 'constituentList', (TType.STRUCT,(Constituent, Constituent.thrift_spec)), None, ), # 3
  )

  def __init__(self, uuid=None, metadata=None, constituentList=None,):
    self.uuid = uuid
    self.metadata = metadata
    self.constituentList = constituentList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.constituentList = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = Constituent()
            _elem33.read(iprot)
            self.constituentList.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Parse')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.constituentList is not None:
      oprot.writeFieldBegin('constituentList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.constituentList))
      for iter34 in self.constituentList:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.constituentList is None:
      raise TProtocol.TProtocolException(message='Required field constituentList is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LatticePath(object):
  """
  Attributes:
   - weight
   - tokenList
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'weight', None, None, ), # 1
    (2, TType.LIST, 'tokenList', (TType.STRUCT,(Token, Token.thrift_spec)), None, ), # 2
  )

  def __init__(self, weight=None, tokenList=None,):
    self.weight = weight
    self.tokenList = tokenList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.weight = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tokenList = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = Token()
            _elem40.read(iprot)
            self.tokenList.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LatticePath')
    if self.weight is not None:
      oprot.writeFieldBegin('weight', TType.DOUBLE, 1)
      oprot.writeDouble(self.weight)
      oprot.writeFieldEnd()
    if self.tokenList is not None:
      oprot.writeFieldBegin('tokenList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tokenList))
      for iter41 in self.tokenList:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tokenList is None:
      raise TProtocol.TProtocolException(message='Required field tokenList is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Arc(object):
  """
  Type for arcs. For epsilon edges, leave 'token' blank.

  Attributes:
   - src
   - dst
   - token
   - weight
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'src', None, None, ), # 1
    (2, TType.I32, 'dst', None, None, ), # 2
    (3, TType.STRUCT, 'token', (Token, Token.thrift_spec), None, ), # 3
    (4, TType.DOUBLE, 'weight', None, None, ), # 4
  )

  def __init__(self, src=None, dst=None, token=None, weight=None,):
    self.src = src
    self.dst = dst
    self.token = token
    self.weight = weight

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.src = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.dst = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.token = Token()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.weight = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Arc')
    if self.src is not None:
      oprot.writeFieldBegin('src', TType.I32, 1)
      oprot.writeI32(self.src)
      oprot.writeFieldEnd()
    if self.dst is not None:
      oprot.writeFieldBegin('dst', TType.I32, 2)
      oprot.writeI32(self.dst)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 3)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.weight is not None:
      oprot.writeFieldBegin('weight', TType.DOUBLE, 4)
      oprot.writeDouble(self.weight)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TokenLattice(object):
  """
  A lattice structure that assigns scores to a set of token
  sequences.  The lattice is encoded as an FSA, where states are
  identified by integers, and each arc is annotated with an
  optional tokens and a weight.  (Arcs with no tokens are
  "epsilon" arcs.)  The lattice has a single start state and a
  single end state.  (You can use epsilon edges to simulate
  multiple start states or multiple end states, if desired.)

  The score of a path through the lattice is the sum of the weights
  of the arcs that make up that path.  A path with a lower score
  is considered "better" than a path with a higher score.

  If possible, path scores should be negative log likelihoods
  (with base e -- e.g. if P=1, then weight=0; and if P=0.5, then
  weight=0.693).  Furthermore, if possible, the path scores should
  be globally normalized (i.e., they should encode probabilities).
  This will allow for them to be combined with other information
  in a reasonable way when determining confidences for system
  outputs.

  TokenLattices should never contain any paths with cycles.  Every
  arc in the lattice should be included in some path from the start
  state to the end state.

  Attributes:
   - startState
   - endState
   - arcList
   - cachedBestPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'startState', None, 0, ), # 1
    (2, TType.I32, 'endState', None, 0, ), # 2
    (3, TType.LIST, 'arcList', (TType.STRUCT,(Arc, Arc.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'cachedBestPath', (LatticePath, LatticePath.thrift_spec), None, ), # 4
  )

  def __init__(self, startState=thrift_spec[1][4], endState=thrift_spec[2][4], arcList=None, cachedBestPath=None,):
    self.startState = startState
    self.endState = endState
    self.arcList = arcList
    self.cachedBestPath = cachedBestPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.startState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.endState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.arcList = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = Arc()
            _elem47.read(iprot)
            self.arcList.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.cachedBestPath = LatticePath()
          self.cachedBestPath.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TokenLattice')
    if self.startState is not None:
      oprot.writeFieldBegin('startState', TType.I32, 1)
      oprot.writeI32(self.startState)
      oprot.writeFieldEnd()
    if self.endState is not None:
      oprot.writeFieldBegin('endState', TType.I32, 2)
      oprot.writeI32(self.endState)
      oprot.writeFieldEnd()
    if self.arcList is not None:
      oprot.writeFieldBegin('arcList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.arcList))
      for iter48 in self.arcList:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.cachedBestPath is not None:
      oprot.writeFieldBegin('cachedBestPath', TType.STRUCT, 4)
      self.cachedBestPath.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.arcList is None:
      raise TProtocol.TProtocolException(message='Required field arcList is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TokenList(object):
  """
  A wrapper around a list of tokens.

  Attributes:
   - tokenList
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tokenList', (TType.STRUCT,(Token, Token.thrift_spec)), None, ), # 1
  )

  def __init__(self, tokenList=None,):
    self.tokenList = tokenList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tokenList = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = Token()
            _elem54.read(iprot)
            self.tokenList.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TokenList')
    if self.tokenList is not None:
      oprot.writeFieldBegin('tokenList', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tokenList))
      for iter55 in self.tokenList:
        iter55.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tokenList is None:
      raise TProtocol.TProtocolException(message='Required field tokenList is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Tokenization(object):
  """
  A theory (or set of alternative theories) about the sequence of
  tokens that make up a sentence.

  This message type is used to record the output of not just for
  tokenizers, but also for a wide variety of other tools, including
  machine translation systems, text normalizers, part-of-speech
  taggers, and stemmers.

  Each Tokenization is encoded using either a TokenList
  or a TokenLattice. (If you want to encode an n-best list, then
  you should store it as n separate Tokenization objects.) The
  "kind" field is used to indicate whether this Tokenization contains
  a list of tokens or a TokenLattice.

  The confidence value for each sequence is determined by combining
  the confidence from the "metadata" field with confidence
  information from individual token sequences as follows:

  <ul>
  <li> For n-best lists:
  metadata.confidence </li>
  <li> For lattices:
  metadata.confidence * exp(-sum(arc.weight)) </li>
  </ul>

  Note: in some cases (such as the output of a machine translation
  tool), the order of the tokens in a token sequence may not
  correspond with the order of their original text span offsets.

  Attributes:
   - uuid
   - metadata: Information about where this tokenization came from.
   - tokenList: A wrapper around an ordered list of the tokens in this tokenization.
  This may also give easy access to the "reconstructed text" associated
  with this tokenization.
  This field should only have a value if kind==TOKEN_LIST.
   - lattice: A lattice that compactly describes a set of token sequences that
  might make up this tokenization.  This field should only have a
  value if kind==LATTICE.
   - kind: Enumerated value indicating whether this tokenization is
  implemented using an n-best list or a lattice.
   - tokenTaggingList
   - parseList
   - dependencyParseList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'tokenList', (TokenList, TokenList.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'lattice', (TokenLattice, TokenLattice.thrift_spec), None, ), # 4
    (5, TType.I32, 'kind', None, None, ), # 5
    (6, TType.LIST, 'tokenTaggingList', (TType.STRUCT,(TokenTagging, TokenTagging.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'parseList', (TType.STRUCT,(Parse, Parse.thrift_spec)), None, ), # 7
    (8, TType.LIST, 'dependencyParseList', (TType.STRUCT,(DependencyParse, DependencyParse.thrift_spec)), None, ), # 8
  )

  def __init__(self, uuid=None, metadata=None, tokenList=None, lattice=None, kind=None, tokenTaggingList=None, parseList=None, dependencyParseList=None,):
    self.uuid = uuid
    self.metadata = metadata
    self.tokenList = tokenList
    self.lattice = lattice
    self.kind = kind
    self.tokenTaggingList = tokenTaggingList
    self.parseList = parseList
    self.dependencyParseList = dependencyParseList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.tokenList = TokenList()
          self.tokenList.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.lattice = TokenLattice()
          self.lattice.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.kind = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.tokenTaggingList = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = TokenTagging()
            _elem61.read(iprot)
            self.tokenTaggingList.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.parseList = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = Parse()
            _elem67.read(iprot)
            self.parseList.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.dependencyParseList = []
          (_etype71, _size68) = iprot.readListBegin()
          for _i72 in xrange(_size68):
            _elem73 = DependencyParse()
            _elem73.read(iprot)
            self.dependencyParseList.append(_elem73)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Tokenization')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.tokenList is not None:
      oprot.writeFieldBegin('tokenList', TType.STRUCT, 3)
      self.tokenList.write(oprot)
      oprot.writeFieldEnd()
    if self.lattice is not None:
      oprot.writeFieldBegin('lattice', TType.STRUCT, 4)
      self.lattice.write(oprot)
      oprot.writeFieldEnd()
    if self.kind is not None:
      oprot.writeFieldBegin('kind', TType.I32, 5)
      oprot.writeI32(self.kind)
      oprot.writeFieldEnd()
    if self.tokenTaggingList is not None:
      oprot.writeFieldBegin('tokenTaggingList', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.tokenTaggingList))
      for iter74 in self.tokenTaggingList:
        iter74.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parseList is not None:
      oprot.writeFieldBegin('parseList', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.parseList))
      for iter75 in self.parseList:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dependencyParseList is not None:
      oprot.writeFieldBegin('dependencyParseList', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.dependencyParseList))
      for iter76 in self.dependencyParseList:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.kind is None:
      raise TProtocol.TProtocolException(message='Required field kind is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Sentence(object):
  """
  A single sentence or utterance in a communication.

  Attributes:
   - uuid
   - tokenization: Theories about the tokens that make up this sentence.  For text
  communications, these tokenizations will typically be generated
  by a tokenizer.  For audio communications, these tokenizations
  will typically be generated by an automatic speech recognizer.

  The "Tokenization" message type is also used to store the output
  of machine translation systems and text normalization
  systems.
   - textSpan: Location of this sentence in the communication text.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
   - rawTextSpan: Location of this sentence in the raw text.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
   - audioSpan: Location of this sentence in the original audio.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'tokenization', (Tokenization, Tokenization.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'textSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'rawTextSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'audioSpan', (concrete.spans.ttypes.AudioSpan, concrete.spans.ttypes.AudioSpan.thrift_spec), None, ), # 5
  )

  def __init__(self, uuid=None, tokenization=None, textSpan=None, rawTextSpan=None, audioSpan=None,):
    self.uuid = uuid
    self.tokenization = tokenization
    self.textSpan = textSpan
    self.rawTextSpan = rawTextSpan
    self.audioSpan = audioSpan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tokenization = Tokenization()
          self.tokenization.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.textSpan = concrete.spans.ttypes.TextSpan()
          self.textSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.rawTextSpan = concrete.spans.ttypes.TextSpan()
          self.rawTextSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.audioSpan = concrete.spans.ttypes.AudioSpan()
          self.audioSpan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Sentence')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.tokenization is not None:
      oprot.writeFieldBegin('tokenization', TType.STRUCT, 2)
      self.tokenization.write(oprot)
      oprot.writeFieldEnd()
    if self.textSpan is not None:
      oprot.writeFieldBegin('textSpan', TType.STRUCT, 3)
      self.textSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.rawTextSpan is not None:
      oprot.writeFieldBegin('rawTextSpan', TType.STRUCT, 4)
      self.rawTextSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.audioSpan is not None:
      oprot.writeFieldBegin('audioSpan', TType.STRUCT, 5)
      self.audioSpan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Section(object):
  """
  A single "section" of a communication, such as a paragraph. Each
  section is defined using a text or audio span, and can optionally
  contain a list of sentences.

  Attributes:
   - uuid: The unique identifier for this section.
   - sentenceList: Theories about how this section is divided into sentences.
   - textSpan: Location of this section in the communication text.

  NOTE: This text span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
   - rawTextSpan: Location of this section in the raw text.

  NOTE: This text span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
   - audioSpan: Location of this section in the original audio.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
   - kind: The type of this section.
   - label: The name of the section. For example, a title of a section on
  Wikipedia.
   - numberList: Position within the communication with respect to other Sections:
  The section number, E.g., 3, or 3.1, or 3.1.2, etc. Aimed at
  Communications with content organized in a hierarchy, such as a Book
  with multiple chapters, then sections, then paragraphs. Or even a
  dense Wikipedia page with subsections. Sections should still be
  arranged linearly, where reading these numbers should not be required
  to get a start-to-finish enumeration of the Communication's content.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.LIST, 'sentenceList', (TType.STRUCT,(Sentence, Sentence.thrift_spec)), None, ), # 2
    (3, TType.STRUCT, 'textSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'rawTextSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 4
    (5, TType.STRING, 'kind', None, None, ), # 5
    (6, TType.STRING, 'label', None, None, ), # 6
    (7, TType.LIST, 'numberList', (TType.I32,None), None, ), # 7
    None, # 8
    (9, TType.STRUCT, 'audioSpan', (concrete.spans.ttypes.AudioSpan, concrete.spans.ttypes.AudioSpan.thrift_spec), None, ), # 9
  )

  def __init__(self, uuid=None, sentenceList=None, textSpan=None, rawTextSpan=None, audioSpan=None, kind=None, label=None, numberList=None,):
    self.uuid = uuid
    self.sentenceList = sentenceList
    self.textSpan = textSpan
    self.rawTextSpan = rawTextSpan
    self.audioSpan = audioSpan
    self.kind = kind
    self.label = label
    self.numberList = numberList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.sentenceList = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = Sentence()
            _elem82.read(iprot)
            self.sentenceList.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.textSpan = concrete.spans.ttypes.TextSpan()
          self.textSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.rawTextSpan = concrete.spans.ttypes.TextSpan()
          self.rawTextSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.audioSpan = concrete.spans.ttypes.AudioSpan()
          self.audioSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.kind = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.label = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.numberList = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = iprot.readI32();
            self.numberList.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Section')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.sentenceList is not None:
      oprot.writeFieldBegin('sentenceList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.sentenceList))
      for iter89 in self.sentenceList:
        iter89.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.textSpan is not None:
      oprot.writeFieldBegin('textSpan', TType.STRUCT, 3)
      self.textSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.rawTextSpan is not None:
      oprot.writeFieldBegin('rawTextSpan', TType.STRUCT, 4)
      self.rawTextSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.kind is not None:
      oprot.writeFieldBegin('kind', TType.STRING, 5)
      oprot.writeString(self.kind.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.label is not None:
      oprot.writeFieldBegin('label', TType.STRING, 6)
      oprot.writeString(self.label.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.numberList is not None:
      oprot.writeFieldBegin('numberList', TType.LIST, 7)
      oprot.writeListBegin(TType.I32, len(self.numberList))
      for iter90 in self.numberList:
        oprot.writeI32(iter90)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.audioSpan is not None:
      oprot.writeFieldBegin('audioSpan', TType.STRUCT, 9)
      self.audioSpan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.kind is None:
      raise TProtocol.TProtocolException(message='Required field kind is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
