# -*- coding: utf-8 -*-
#
# Autogenerated by Thrift Compiler (0.18.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import concrete.metadata.ttypes
import concrete.spans.ttypes
import concrete.uuid.ttypes
import concrete.language.ttypes

from thrift.transport import TTransport
all_structs = []


class TokenizationKind(object):
    """
    Enumerated types of Tokenizations

    """
    TOKEN_LIST = 1
    TOKEN_LATTICE = 2

    _VALUES_TO_NAMES = {
        1: "TOKEN_LIST",
        2: "TOKEN_LATTICE",
    }

    _NAMES_TO_VALUES = {
        "TOKEN_LIST": 1,
        "TOKEN_LATTICE": 2,
    }


class Constituent(object):
    """
    A single parse constituent (or "phrase").

    Attributes:
     - id: A parse-relative identifier for this consistuent. Together
    with the UUID for a Parse, this can be used to define
    pointers to specific constituents.
     - tag: A description of this constituency node, e.g. the category "NP".
    For leaf nodes, this should be a word and for pre-terminal nodes
    this should be a POS tag.
     - childList
     - headChildIndex: The index of the head child of this constituent. I.e., the
    head child of constituent <tt>c</tt> is
    <tt>c.children[c.head_child_index]</tt>. A value of -1
    indicates that no child head was identified.
     - start: The first token (inclusive) of this constituent in the
    parent Tokenization. Almost certainly should be populated.
     - ending: The last token (exclusive) of this constituent in the
    parent Tokenization. Almost certainly should be populated.

    """


    def __init__(self, id=None, tag=None, childList=None, headChildIndex=-1, start=None, ending=None,):
        self.id = id
        self.tag = tag
        self.childList = childList
        self.headChildIndex = headChildIndex
        self.start = start
        self.ending = ending

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tag = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.childList = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.childList.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.headChildIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.ending = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Constituent')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRING, 2)
            oprot.writeString(self.tag.encode('utf-8') if sys.version_info[0] == 2 else self.tag)
            oprot.writeFieldEnd()
        if self.childList is not None:
            oprot.writeFieldBegin('childList', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.childList))
            for iter6 in self.childList:
                oprot.writeI32(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.headChildIndex is not None:
            oprot.writeFieldBegin('headChildIndex', TType.I32, 4)
            oprot.writeI32(self.headChildIndex)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 5)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.ending is not None:
            oprot.writeFieldBegin('ending', TType.I32, 6)
            oprot.writeI32(self.ending)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.childList is None:
            raise TProtocolException(message='Required field childList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Parse(object):
    """
    A theory about the syntactic parse of a sentence.

    \note If we add support for parse forests in the future, then it
    will most likely be done by adding a new field (e.g.
    "<tt>forest_root</tt>") that uses a new struct type to encode the
    forest. A "<tt>kind</tt>" field might also be added (analogous to
    <tt>Tokenization.kind</tt>) to indicate whether a parse is encoded
    using a simple tree or a parse forest.

    Attributes:
     - uuid
     - metadata
     - constituentList

    """


    def __init__(self, uuid=None, metadata=None, constituentList=None,):
        self.uuid = uuid
        self.metadata = metadata
        self.constituentList = constituentList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.constituentList = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = Constituent()
                        _elem12.read(iprot)
                        self.constituentList.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Parse')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.constituentList is not None:
            oprot.writeFieldBegin('constituentList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.constituentList))
            for iter13 in self.constituentList:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        if self.constituentList is None:
            raise TProtocolException(message='Required field constituentList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConstituentRef(object):
    """
    A reference to a Constituent within a Parse.

    Attributes:
     - parseId: The UUID of the Parse that this Constituent belongs to.
     - constituentIndex: The index in the constituent list of this Constituent.

    """


    def __init__(self, parseId=None, constituentIndex=None,):
        self.parseId = parseId
        self.constituentIndex = constituentIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.parseId = concrete.uuid.ttypes.UUID()
                    self.parseId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.constituentIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConstituentRef')
        if self.parseId is not None:
            oprot.writeFieldBegin('parseId', TType.STRUCT, 1)
            self.parseId.write(oprot)
            oprot.writeFieldEnd()
        if self.constituentIndex is not None:
            oprot.writeFieldBegin('constituentIndex', TType.I32, 2)
            oprot.writeI32(self.constituentIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.parseId is None:
            raise TProtocolException(message='Required field parseId is unset!')
        if self.constituentIndex is None:
            raise TProtocolException(message='Required field constituentIndex is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Dependency(object):
    """
    A syntactic edge between two tokens in a tokenized sentence.

    Attributes:
     - gov: The governor or the head token. 0 indexed.
     - dep: The dependent token. 0 indexed.
     - edgeType: The relation that holds between gov and dep.

    """


    def __init__(self, gov=-1, dep=None, edgeType=None,):
        self.gov = gov
        self.dep = dep
        self.edgeType = edgeType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.gov = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dep = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.edgeType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Dependency')
        if self.gov is not None:
            oprot.writeFieldBegin('gov', TType.I32, 1)
            oprot.writeI32(self.gov)
            oprot.writeFieldEnd()
        if self.dep is not None:
            oprot.writeFieldBegin('dep', TType.I32, 2)
            oprot.writeI32(self.dep)
            oprot.writeFieldEnd()
        if self.edgeType is not None:
            oprot.writeFieldBegin('edgeType', TType.STRING, 3)
            oprot.writeString(self.edgeType.encode('utf-8') if sys.version_info[0] == 2 else self.edgeType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dep is None:
            raise TProtocolException(message='Required field dep is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DependencyParseStructure(object):
    """
    Information about the structure of a dependency parse.
    This information is computable from the list of dependencies,
    but this allows the consumer to make (verified) assumptions
    about the dependencies being processed.

    Attributes:
     - isAcyclic: True iff there are no cycles in the dependency graph.
     - isConnected: True iff the dependency graph forms a single connected component.
     - isSingleHeaded: True iff every node in the dependency parse has at most
    one head/parent/governor.
     - isProjective: True iff there are no crossing edges in the dependency parse.

    """


    def __init__(self, isAcyclic=None, isConnected=None, isSingleHeaded=None, isProjective=None,):
        self.isAcyclic = isAcyclic
        self.isConnected = isConnected
        self.isSingleHeaded = isSingleHeaded
        self.isProjective = isProjective

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.isAcyclic = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isConnected = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isSingleHeaded = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isProjective = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DependencyParseStructure')
        if self.isAcyclic is not None:
            oprot.writeFieldBegin('isAcyclic', TType.BOOL, 1)
            oprot.writeBool(self.isAcyclic)
            oprot.writeFieldEnd()
        if self.isConnected is not None:
            oprot.writeFieldBegin('isConnected', TType.BOOL, 2)
            oprot.writeBool(self.isConnected)
            oprot.writeFieldEnd()
        if self.isSingleHeaded is not None:
            oprot.writeFieldBegin('isSingleHeaded', TType.BOOL, 3)
            oprot.writeBool(self.isSingleHeaded)
            oprot.writeFieldEnd()
        if self.isProjective is not None:
            oprot.writeFieldBegin('isProjective', TType.BOOL, 4)
            oprot.writeBool(self.isProjective)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.isAcyclic is None:
            raise TProtocolException(message='Required field isAcyclic is unset!')
        if self.isConnected is None:
            raise TProtocolException(message='Required field isConnected is unset!')
        if self.isSingleHeaded is None:
            raise TProtocolException(message='Required field isSingleHeaded is unset!')
        if self.isProjective is None:
            raise TProtocolException(message='Required field isProjective is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DependencyParse(object):
    """
    Represents a dependency parse with typed edges.

    Attributes:
     - uuid
     - metadata
     - dependencyList
     - structureInformation

    """


    def __init__(self, uuid=None, metadata=None, dependencyList=None, structureInformation=None,):
        self.uuid = uuid
        self.metadata = metadata
        self.dependencyList = dependencyList
        self.structureInformation = structureInformation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.dependencyList = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = Dependency()
                        _elem19.read(iprot)
                        self.dependencyList.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.structureInformation = DependencyParseStructure()
                    self.structureInformation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DependencyParse')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.dependencyList is not None:
            oprot.writeFieldBegin('dependencyList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.dependencyList))
            for iter20 in self.dependencyList:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.structureInformation is not None:
            oprot.writeFieldBegin('structureInformation', TType.STRUCT, 4)
            self.structureInformation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        if self.dependencyList is None:
            raise TProtocolException(message='Required field dependencyList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Token(object):
    """
    A single token (typically a word) in a communication. The exact
    definition of what counts as a token is left up to the tools that
    generate token sequences.

    Usually, each token will include at least a text string.

    Attributes:
     - tokenIndex: A 0-based tokenization-relative identifier for this token that
    represents the order that this token appears in the
    sentence. Together with the UUID for a Tokenization, this can be
    used to define pointers to specific tokens. If a Tokenization
    object contains multiple Token objects with the same id (e.g., in
    different n-best lists), then all of their other fields *must* be
    identical as well.
     - text: The text associated with this token.
    Note - we may have a destructive tokenizer (e.g., Stanford rewriting)
    and as a result, we want to maintain this field.
     - textSpan: Location of this token in this perspective's text (.text field).
    In cases where this token does not correspond directly with any
    text span in the text (such as word insertion during MT),
    this field may be given a value indicating "approximately" where
    the token comes from. A span covering the entire sentence may be
    used if no more precise value seems appropriate.

    NOTE: This span represents a best guess, or 'provenance':
    it cannot be guaranteed that this text span matches the _exact_
    text of the document, but is the annotation's best
    effort at such a representation.
     - rawTextSpan: Location of this token in the original, raw text (.originalText
    field).  In cases where this token does not correspond directly
    with any text span in the original text (such as word insertion
    during MT), this field may be given a value indicating
    "approximately" where the token comes from. A span covering the
    entire sentence may be used if no more precise value seems
    appropriate.

    NOTE: This span represents a best guess, or 'provenance':
    it cannot be guaranteed that this text span matches the _exact_
    text of the original raw document, but is the annotation's best
    effort at such a representation.
     - audioSpan: Location of this token in the original audio.

    NOTE: This span represents a best guess, or 'provenance':
    it cannot be guaranteed that this text span matches the _exact_
    text of the original document, but is the annotation's best
    effort at such a representation.

    """


    def __init__(self, tokenIndex=None, text=None, textSpan=None, rawTextSpan=None, audioSpan=None,):
        self.tokenIndex = tokenIndex
        self.text = text
        self.textSpan = textSpan
        self.rawTextSpan = rawTextSpan
        self.audioSpan = audioSpan

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tokenIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.text = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.textSpan = concrete.spans.ttypes.TextSpan()
                    self.textSpan.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.rawTextSpan = concrete.spans.ttypes.TextSpan()
                    self.rawTextSpan.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.audioSpan = concrete.spans.ttypes.AudioSpan()
                    self.audioSpan.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Token')
        if self.tokenIndex is not None:
            oprot.writeFieldBegin('tokenIndex', TType.I32, 1)
            oprot.writeI32(self.tokenIndex)
            oprot.writeFieldEnd()
        if self.text is not None:
            oprot.writeFieldBegin('text', TType.STRING, 2)
            oprot.writeString(self.text.encode('utf-8') if sys.version_info[0] == 2 else self.text)
            oprot.writeFieldEnd()
        if self.textSpan is not None:
            oprot.writeFieldBegin('textSpan', TType.STRUCT, 3)
            self.textSpan.write(oprot)
            oprot.writeFieldEnd()
        if self.rawTextSpan is not None:
            oprot.writeFieldBegin('rawTextSpan', TType.STRUCT, 4)
            self.rawTextSpan.write(oprot)
            oprot.writeFieldEnd()
        if self.audioSpan is not None:
            oprot.writeFieldBegin('audioSpan', TType.STRUCT, 5)
            self.audioSpan.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tokenIndex is None:
            raise TProtocolException(message='Required field tokenIndex is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TokenRefSequence(object):
    """
    A list of pointers to tokens that all belong to the same
    tokenization.

    Attributes:
     - tokenIndexList: The tokenization-relative identifiers for each token that is
    included in this sequence.
     - anchorTokenIndex: An optional field that can be used to describe
    the root of a sentence (if this sequence is a full sentence),
    the head of a constituent (if this sequence is a constituent),
    or some other form of "canonical" token in this sequence if,
    for instance, it is not easy to map this sequence to a another
    annotation that has a head.

    This field is defined with respect to the Tokenization given
    by tokenizationId, and not to this object's tokenIndexList.
     - tokenizationId: The UUID of the tokenization that contains the tokens.
     - textSpan: The text span in the main text (.text field) associated with this
    TokenRefSequence.

    NOTE: This span represents a best guess, or 'provenance': it
    cannot be guaranteed that this text span matches the _exact_ text
    of the original document, but is the annotation's best effort at
    such a representation.
     - rawTextSpan: The text span in the original text (.originalText field)
    associated with this TokenRefSequence.

    NOTE: This span represents a best guess, or 'provenance': it
    cannot be guaranteed that this text span matches the _exact_ text
    of the original raw document, but is the annotation's best effort
    at such a representation.
     - audioSpan: The audio span associated with this TokenRefSequence.

    NOTE: This span represents a best guess, or 'provenance':
    it cannot be guaranteed that this text span matches the _exact_
    text of the original document, but is the annotation's best
    effort at such a representation.
     - dependencies: Use this field to reference a dependency tree fragment
    such as a shortest path or all the dependents in a constituent.
     - constituent: Use this field to specify an entire constituent in a parse tree.
    Prefer textSpan over this field unless a node in a tree is needed.

    """


    def __init__(self, tokenIndexList=None, anchorTokenIndex=-1, tokenizationId=None, textSpan=None, rawTextSpan=None, audioSpan=None, dependencies=None, constituent=None,):
        self.tokenIndexList = tokenIndexList
        self.anchorTokenIndex = anchorTokenIndex
        self.tokenizationId = tokenizationId
        self.textSpan = textSpan
        self.rawTextSpan = rawTextSpan
        self.audioSpan = audioSpan
        self.dependencies = dependencies
        self.constituent = constituent

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tokenIndexList = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readI32()
                        self.tokenIndexList.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.anchorTokenIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.tokenizationId = concrete.uuid.ttypes.UUID()
                    self.tokenizationId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.textSpan = concrete.spans.ttypes.TextSpan()
                    self.textSpan.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.rawTextSpan = concrete.spans.ttypes.TextSpan()
                    self.rawTextSpan.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.audioSpan = concrete.spans.ttypes.AudioSpan()
                    self.audioSpan.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.dependencies = []
                    (_etype30, _size27) = iprot.readListBegin()
                    for _i31 in range(_size27):
                        _elem32 = Dependency()
                        _elem32.read(iprot)
                        self.dependencies.append(_elem32)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.constituent = ConstituentRef()
                    self.constituent.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TokenRefSequence')
        if self.tokenIndexList is not None:
            oprot.writeFieldBegin('tokenIndexList', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.tokenIndexList))
            for iter33 in self.tokenIndexList:
                oprot.writeI32(iter33)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.anchorTokenIndex is not None:
            oprot.writeFieldBegin('anchorTokenIndex', TType.I32, 2)
            oprot.writeI32(self.anchorTokenIndex)
            oprot.writeFieldEnd()
        if self.tokenizationId is not None:
            oprot.writeFieldBegin('tokenizationId', TType.STRUCT, 3)
            self.tokenizationId.write(oprot)
            oprot.writeFieldEnd()
        if self.textSpan is not None:
            oprot.writeFieldBegin('textSpan', TType.STRUCT, 4)
            self.textSpan.write(oprot)
            oprot.writeFieldEnd()
        if self.rawTextSpan is not None:
            oprot.writeFieldBegin('rawTextSpan', TType.STRUCT, 5)
            self.rawTextSpan.write(oprot)
            oprot.writeFieldEnd()
        if self.audioSpan is not None:
            oprot.writeFieldBegin('audioSpan', TType.STRUCT, 6)
            self.audioSpan.write(oprot)
            oprot.writeFieldEnd()
        if self.dependencies is not None:
            oprot.writeFieldBegin('dependencies', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.dependencies))
            for iter34 in self.dependencies:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.constituent is not None:
            oprot.writeFieldBegin('constituent', TType.STRUCT, 8)
            self.constituent.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tokenIndexList is None:
            raise TProtocolException(message='Required field tokenIndexList is unset!')
        if self.tokenizationId is None:
            raise TProtocolException(message='Required field tokenizationId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TaggedToken(object):
    """
    Attributes:
     - tokenIndex: A pointer to the token being tagged.

    Token indices are 0-based. These indices are also 0-based.
     - tag: A string containing the annotation.
    If the tag set you are using is not case sensitive,
    then all part of speech tags should be normalized to upper case.
     - confidence: Confidence of the annotation.
     - tagList: A list of strings that represent a distribution of possible
    tags for this token.

    If populated, the 'tag' field should also be populated
    with the "best" value from this list.
     - confidenceList: A list of doubles that represent confidences associated with
    the tags in the 'tagList' field.

    If populated, the 'confidence' field should also be populated
    with the confidence associated with the "best" tag in 'tagList'.

    """


    def __init__(self, tokenIndex=None, tag=None, confidence=None, tagList=None, confidenceList=None,):
        self.tokenIndex = tokenIndex
        self.tag = tag
        self.confidence = confidence
        self.tagList = tagList
        self.confidenceList = confidenceList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tokenIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tag = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.confidence = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.tagList = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tagList.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.confidenceList = []
                    (_etype44, _size41) = iprot.readListBegin()
                    for _i45 in range(_size41):
                        _elem46 = iprot.readDouble()
                        self.confidenceList.append(_elem46)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TaggedToken')
        if self.tokenIndex is not None:
            oprot.writeFieldBegin('tokenIndex', TType.I32, 1)
            oprot.writeI32(self.tokenIndex)
            oprot.writeFieldEnd()
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRING, 2)
            oprot.writeString(self.tag.encode('utf-8') if sys.version_info[0] == 2 else self.tag)
            oprot.writeFieldEnd()
        if self.confidence is not None:
            oprot.writeFieldBegin('confidence', TType.DOUBLE, 3)
            oprot.writeDouble(self.confidence)
            oprot.writeFieldEnd()
        if self.tagList is not None:
            oprot.writeFieldBegin('tagList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.tagList))
            for iter47 in self.tagList:
                oprot.writeString(iter47.encode('utf-8') if sys.version_info[0] == 2 else iter47)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.confidenceList is not None:
            oprot.writeFieldBegin('confidenceList', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.confidenceList))
            for iter48 in self.confidenceList:
                oprot.writeDouble(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TokenTagging(object):
    """
    A theory about some token-level annotation.
    The TokenTagging consists of a mapping from tokens
    (using token ids) to string tags (e.g. part-of-speech tags or lemmas).

    The mapping defined by a TokenTagging may be partial --
    i.e., some tokens may not be assigned any part of speech tags.

    For lattice tokenizations, you may need to create multiple
    part-of-speech taggings (for different paths through the lattice),
    since the appropriate tag for a given token may depend on the path
    taken. For example, you might define a separate
    TokenTagging for each of the top K paths, which leaves all
    tokens that are not part of the path unlabeled.

    Currently, we use strings to encode annotations. In
    the future, we may add fields for encoding specific tag sets
    (eg treebank tags), or for adding compound tags.

    Attributes:
     - uuid: The UUID of this TokenTagging object.
     - metadata: Information about where the annotation came from.
    This should be used to tell between gold-standard annotations
    and automatically generated theories about the data
     - taggedTokenList: The mapping from tokens to annotations.
    This may be a partial mapping.
     - taggingType: An ontology-backed string that represents the
    type of token taggings this TokenTagging object
    produces.

    """


    def __init__(self, uuid=None, metadata=None, taggedTokenList=None, taggingType=None,):
        self.uuid = uuid
        self.metadata = metadata
        self.taggedTokenList = taggedTokenList
        self.taggingType = taggingType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.taggedTokenList = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = TaggedToken()
                        _elem54.read(iprot)
                        self.taggedTokenList.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.taggingType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TokenTagging')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.taggedTokenList is not None:
            oprot.writeFieldBegin('taggedTokenList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.taggedTokenList))
            for iter55 in self.taggedTokenList:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.taggingType is not None:
            oprot.writeFieldBegin('taggingType', TType.STRING, 4)
            oprot.writeString(self.taggingType.encode('utf-8') if sys.version_info[0] == 2 else self.taggingType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        if self.taggedTokenList is None:
            raise TProtocolException(message='Required field taggedTokenList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LatticePath(object):
    """
    Attributes:
     - weight
     - tokenList

    """


    def __init__(self, weight=None, tokenList=None,):
        self.weight = weight
        self.tokenList = tokenList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.weight = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tokenList = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = Token()
                        _elem61.read(iprot)
                        self.tokenList.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LatticePath')
        if self.weight is not None:
            oprot.writeFieldBegin('weight', TType.DOUBLE, 1)
            oprot.writeDouble(self.weight)
            oprot.writeFieldEnd()
        if self.tokenList is not None:
            oprot.writeFieldBegin('tokenList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.tokenList))
            for iter62 in self.tokenList:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tokenList is None:
            raise TProtocolException(message='Required field tokenList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Arc(object):
    """
    Type for arcs. For epsilon edges, leave 'token' blank.

    Attributes:
     - src
     - dst
     - token
     - weight

    """


    def __init__(self, src=None, dst=None, token=None, weight=None,):
        self.src = src
        self.dst = dst
        self.token = token
        self.weight = weight

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.src = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dst = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.token = Token()
                    self.token.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.weight = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Arc')
        if self.src is not None:
            oprot.writeFieldBegin('src', TType.I32, 1)
            oprot.writeI32(self.src)
            oprot.writeFieldEnd()
        if self.dst is not None:
            oprot.writeFieldBegin('dst', TType.I32, 2)
            oprot.writeI32(self.dst)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRUCT, 3)
            self.token.write(oprot)
            oprot.writeFieldEnd()
        if self.weight is not None:
            oprot.writeFieldBegin('weight', TType.DOUBLE, 4)
            oprot.writeDouble(self.weight)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TokenLattice(object):
    """
    A lattice structure that assigns scores to a set of token
    sequences.  The lattice is encoded as an FSA, where states are
    identified by integers, and each arc is annotated with an
    optional tokens and a weight.  (Arcs with no tokens are
    "epsilon" arcs.)  The lattice has a single start state and a
    single end state.  (You can use epsilon edges to simulate
    multiple start states or multiple end states, if desired.)

    The score of a path through the lattice is the sum of the weights
    of the arcs that make up that path.  A path with a lower score
    is considered "better" than a path with a higher score.

    If possible, path scores should be negative log likelihoods
    (with base e -- e.g. if P=1, then weight=0; and if P=0.5, then
    weight=0.693).  Furthermore, if possible, the path scores should
    be globally normalized (i.e., they should encode probabilities).
    This will allow for them to be combined with other information
    in a reasonable way when determining confidences for system
    outputs.

    TokenLattices should never contain any paths with cycles.  Every
    arc in the lattice should be included in some path from the start
    state to the end state.

    Attributes:
     - startState
     - endState
     - arcList
     - cachedBestPath

    """


    def __init__(self, startState=0, endState=0, arcList=None, cachedBestPath=None,):
        self.startState = startState
        self.endState = endState
        self.arcList = arcList
        self.cachedBestPath = cachedBestPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.startState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.endState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.arcList = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = Arc()
                        _elem68.read(iprot)
                        self.arcList.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.cachedBestPath = LatticePath()
                    self.cachedBestPath.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TokenLattice')
        if self.startState is not None:
            oprot.writeFieldBegin('startState', TType.I32, 1)
            oprot.writeI32(self.startState)
            oprot.writeFieldEnd()
        if self.endState is not None:
            oprot.writeFieldBegin('endState', TType.I32, 2)
            oprot.writeI32(self.endState)
            oprot.writeFieldEnd()
        if self.arcList is not None:
            oprot.writeFieldBegin('arcList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.arcList))
            for iter69 in self.arcList:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cachedBestPath is not None:
            oprot.writeFieldBegin('cachedBestPath', TType.STRUCT, 4)
            self.cachedBestPath.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.arcList is None:
            raise TProtocolException(message='Required field arcList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TokenList(object):
    """
    A wrapper around a list of tokens.

    Attributes:
     - tokenList

    """


    def __init__(self, tokenList=None,):
        self.tokenList = tokenList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tokenList = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = Token()
                        _elem75.read(iprot)
                        self.tokenList.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TokenList')
        if self.tokenList is not None:
            oprot.writeFieldBegin('tokenList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.tokenList))
            for iter76 in self.tokenList:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tokenList is None:
            raise TProtocolException(message='Required field tokenList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SpanLink(object):
    """
    A collection of tokens that represent a link to another resource.
    This resource might be another Concrete object (e.g., another
    Concrete Communication), represented with the 'concreteTarget'
    field, or it could link to a resource outside of Concrete via the
    'externalTarget' field.

    Attributes:
     - tokens: The tokens that make up this SpanLink object.
     - concreteTarget
     - externalTarget
     - linkType

    """


    def __init__(self, tokens=None, concreteTarget=None, externalTarget=None, linkType=None,):
        self.tokens = tokens
        self.concreteTarget = concreteTarget
        self.externalTarget = externalTarget
        self.linkType = linkType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tokens = TokenRefSequence()
                    self.tokens.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.concreteTarget = concrete.uuid.ttypes.UUID()
                    self.concreteTarget.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.externalTarget = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.linkType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpanLink')
        if self.tokens is not None:
            oprot.writeFieldBegin('tokens', TType.STRUCT, 1)
            self.tokens.write(oprot)
            oprot.writeFieldEnd()
        if self.concreteTarget is not None:
            oprot.writeFieldBegin('concreteTarget', TType.STRUCT, 2)
            self.concreteTarget.write(oprot)
            oprot.writeFieldEnd()
        if self.externalTarget is not None:
            oprot.writeFieldBegin('externalTarget', TType.STRING, 3)
            oprot.writeString(self.externalTarget.encode('utf-8') if sys.version_info[0] == 2 else self.externalTarget)
            oprot.writeFieldEnd()
        if self.linkType is not None:
            oprot.writeFieldBegin('linkType', TType.STRING, 4)
            oprot.writeString(self.linkType.encode('utf-8') if sys.version_info[0] == 2 else self.linkType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tokens is None:
            raise TProtocolException(message='Required field tokens is unset!')
        if self.linkType is None:
            raise TProtocolException(message='Required field linkType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Tokenization(object):
    """
    A theory (or set of alternative theories) about the sequence of
    tokens that make up a sentence.

    This message type is used to record the output of not just for
    tokenizers, but also for a wide variety of other tools, including
    machine translation systems, text normalizers, part-of-speech
    taggers, and stemmers.

    Each Tokenization is encoded using either a TokenList
    or a TokenLattice. (If you want to encode an n-best list, then
    you should store it as n separate Tokenization objects.) The
    "kind" field is used to indicate whether this Tokenization contains
    a list of tokens or a TokenLattice.

    The confidence value for each sequence is determined by combining
    the confidence from the "metadata" field with confidence
    information from individual token sequences as follows:

    <ul>
    <li> For n-best lists:
    metadata.confidence </li>
    <li> For lattices:
    metadata.confidence * exp(-sum(arc.weight)) </li>
    </ul>

    Note: in some cases (such as the output of a machine translation
    tool), the order of the tokens in a token sequence may not
    correspond with the order of their original text span offsets.

    Attributes:
     - uuid
     - metadata: Information about where this tokenization came from.
     - tokenList: A wrapper around an ordered list of the tokens in this tokenization.
    This may also give easy access to the "reconstructed text" associated
    with this tokenization.
    This field should only have a value if kind==TOKEN_LIST.
     - lattice: A lattice that compactly describes a set of token sequences that
    might make up this tokenization.  This field should only have a
    value if kind==LATTICE.
     - kind: Enumerated value indicating whether this tokenization is
    implemented using an n-best list or a lattice.
     - tokenTaggingList
     - parseList
     - dependencyParseList
     - spanLinkList

    """


    def __init__(self, uuid=None, metadata=None, tokenList=None, lattice=None, kind=None, tokenTaggingList=None, parseList=None, dependencyParseList=None, spanLinkList=None,):
        self.uuid = uuid
        self.metadata = metadata
        self.tokenList = tokenList
        self.lattice = lattice
        self.kind = kind
        self.tokenTaggingList = tokenTaggingList
        self.parseList = parseList
        self.dependencyParseList = dependencyParseList
        self.spanLinkList = spanLinkList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.tokenList = TokenList()
                    self.tokenList.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.lattice = TokenLattice()
                    self.lattice.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.kind = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.tokenTaggingList = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = TokenTagging()
                        _elem82.read(iprot)
                        self.tokenTaggingList.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.parseList = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = Parse()
                        _elem88.read(iprot)
                        self.parseList.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.dependencyParseList = []
                    (_etype92, _size89) = iprot.readListBegin()
                    for _i93 in range(_size89):
                        _elem94 = DependencyParse()
                        _elem94.read(iprot)
                        self.dependencyParseList.append(_elem94)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.spanLinkList = []
                    (_etype98, _size95) = iprot.readListBegin()
                    for _i99 in range(_size95):
                        _elem100 = SpanLink()
                        _elem100.read(iprot)
                        self.spanLinkList.append(_elem100)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Tokenization')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.tokenList is not None:
            oprot.writeFieldBegin('tokenList', TType.STRUCT, 3)
            self.tokenList.write(oprot)
            oprot.writeFieldEnd()
        if self.lattice is not None:
            oprot.writeFieldBegin('lattice', TType.STRUCT, 4)
            self.lattice.write(oprot)
            oprot.writeFieldEnd()
        if self.kind is not None:
            oprot.writeFieldBegin('kind', TType.I32, 5)
            oprot.writeI32(self.kind)
            oprot.writeFieldEnd()
        if self.tokenTaggingList is not None:
            oprot.writeFieldBegin('tokenTaggingList', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.tokenTaggingList))
            for iter101 in self.tokenTaggingList:
                iter101.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.parseList is not None:
            oprot.writeFieldBegin('parseList', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.parseList))
            for iter102 in self.parseList:
                iter102.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dependencyParseList is not None:
            oprot.writeFieldBegin('dependencyParseList', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.dependencyParseList))
            for iter103 in self.dependencyParseList:
                iter103.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.spanLinkList is not None:
            oprot.writeFieldBegin('spanLinkList', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.spanLinkList))
            for iter104 in self.spanLinkList:
                iter104.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        if self.kind is None:
            raise TProtocolException(message='Required field kind is unset!')
        return

    def __repr__(self):
        # The implementation of this function is NOT auto-generated
        # Prevent infinite recursion caused by backpointer added by
        #   concrete.util.references.add_references_to_communication()
        dict_without_backpointer = self.__dict__.copy()
        if 'sentence' in dict_without_backpointer:
            dict_without_backpointer.pop('sentence')
        L = ['%s=%r' % (key, value)
             for key, value in dict_without_backpointer.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Sentence(object):
    """
    A single sentence or utterance in a communication.

    Attributes:
     - uuid
     - tokenization: Theory about the tokens that make up this sentence.  For text
    communications, these tokenizations will typically be generated
    by a tokenizer.  For audio communications, these tokenizations
    will typically be generated by an automatic speech recognizer.

    The "Tokenization" message type is also used to store the output
    of machine translation systems and text normalization
    systems.
     - textSpan: Location of this sentence in the communication text.

    NOTE: This span represents a best guess, or 'provenance':
    it cannot be guaranteed that this text span matches the _exact_
    text of the original document, but is the annotation's best
    effort at such a representation.
     - rawTextSpan: Location of this sentence in the raw text.

    NOTE: This span represents a best guess, or 'provenance':
    it cannot be guaranteed that this text span matches the _exact_
    text of the original document, but is the annotation's best
    effort at such a representation.
     - audioSpan: Location of this sentence in the original audio.

    NOTE: This span represents a best guess, or 'provenance':
    it cannot be guaranteed that this text span matches the _exact_
    text of the original document, but is the annotation's best
    effort at such a representation.

    """


    def __init__(self, uuid=None, tokenization=None, textSpan=None, rawTextSpan=None, audioSpan=None,):
        self.uuid = uuid
        self.tokenization = tokenization
        self.textSpan = textSpan
        self.rawTextSpan = rawTextSpan
        self.audioSpan = audioSpan

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.tokenization = Tokenization()
                    self.tokenization.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.textSpan = concrete.spans.ttypes.TextSpan()
                    self.textSpan.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.rawTextSpan = concrete.spans.ttypes.TextSpan()
                    self.rawTextSpan.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.audioSpan = concrete.spans.ttypes.AudioSpan()
                    self.audioSpan.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Sentence')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.tokenization is not None:
            oprot.writeFieldBegin('tokenization', TType.STRUCT, 2)
            self.tokenization.write(oprot)
            oprot.writeFieldEnd()
        if self.textSpan is not None:
            oprot.writeFieldBegin('textSpan', TType.STRUCT, 3)
            self.textSpan.write(oprot)
            oprot.writeFieldEnd()
        if self.rawTextSpan is not None:
            oprot.writeFieldBegin('rawTextSpan', TType.STRUCT, 4)
            self.rawTextSpan.write(oprot)
            oprot.writeFieldEnd()
        if self.audioSpan is not None:
            oprot.writeFieldBegin('audioSpan', TType.STRUCT, 5)
            self.audioSpan.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Section(object):
    """
    A single "section" of a communication, such as a paragraph. Each
    section is defined using a text or audio span, and can optionally
    contain a list of sentences.

    Attributes:
     - uuid: The unique identifier for this section.
     - sentenceList: The sentences of this "section."
     - textSpan: Location of this section in the communication text.

    NOTE: This text span represents a best guess, or 'provenance':
    it cannot be guaranteed that this text span matches the _exact_
    text of the original document, but is the annotation's best
    effort at such a representation.
     - rawTextSpan: Location of this section in the raw text.

    NOTE: This text span represents a best guess, or 'provenance':
    it cannot be guaranteed that this text span matches the _exact_
    text of the original document, but is the annotation's best
    effort at such a representation.
     - audioSpan: Location of this section in the original audio.

    NOTE: This span represents a best guess, or 'provenance':
    it cannot be guaranteed that this text span matches the _exact_
    text of the original document, but is the annotation's best
    effort at such a representation.
     - kind: A short, sometimes corpus-specific term characterizing the nature
    of the section; may change in a future version of concrete.  This
    often acts as a coarse-grained descriptor that is used for
    filtering.  For example, Gigaword uses the section kind "passage"
    to distinguish content-bearing paragraphs in the body of an
    article from other paragraphs, such as the headline and dateline.
     - label: The name of the section. For example, a title of a section on
    Wikipedia.
     - numberList: Position within the communication with respect to other Sections:
    The section number, E.g., 3, or 3.1, or 3.1.2, etc. Aimed at
    Communications with content organized in a hierarchy, such as a Book
    with multiple chapters, then sections, then paragraphs. Or even a
    dense Wikipedia page with subsections. Sections should still be
    arranged linearly, where reading these numbers should not be required
    to get a start-to-finish enumeration of the Communication's content.
     - lidList: An optional field to be used for multi-language documents.

    This field should be populated when a section is inside of
    a document that contains multiple languages.

    Minimally, each block of text in one language should be it's own
    section. For example, if a paragraph is in English and the
    paragraph afterwards is in French, these should be separated into
    two different sections, allowing language-specific analytics to
    run on appropriate sections.

    """


    def __init__(self, uuid=None, sentenceList=None, textSpan=None, rawTextSpan=None, audioSpan=None, kind=None, label=None, numberList=None, lidList=None,):
        self.uuid = uuid
        self.sentenceList = sentenceList
        self.textSpan = textSpan
        self.rawTextSpan = rawTextSpan
        self.audioSpan = audioSpan
        self.kind = kind
        self.label = label
        self.numberList = numberList
        self.lidList = lidList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.uuid = concrete.uuid.ttypes.UUID()
                    self.uuid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sentenceList = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = Sentence()
                        _elem110.read(iprot)
                        self.sentenceList.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.textSpan = concrete.spans.ttypes.TextSpan()
                    self.textSpan.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.rawTextSpan = concrete.spans.ttypes.TextSpan()
                    self.rawTextSpan.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.audioSpan = concrete.spans.ttypes.AudioSpan()
                    self.audioSpan.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.kind = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.label = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.numberList = []
                    (_etype114, _size111) = iprot.readListBegin()
                    for _i115 in range(_size111):
                        _elem116 = iprot.readI32()
                        self.numberList.append(_elem116)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.lidList = []
                    (_etype120, _size117) = iprot.readListBegin()
                    for _i121 in range(_size117):
                        _elem122 = concrete.language.ttypes.LanguageIdentification()
                        _elem122.read(iprot)
                        self.lidList.append(_elem122)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Section')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
            self.uuid.write(oprot)
            oprot.writeFieldEnd()
        if self.sentenceList is not None:
            oprot.writeFieldBegin('sentenceList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.sentenceList))
            for iter123 in self.sentenceList:
                iter123.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.textSpan is not None:
            oprot.writeFieldBegin('textSpan', TType.STRUCT, 3)
            self.textSpan.write(oprot)
            oprot.writeFieldEnd()
        if self.rawTextSpan is not None:
            oprot.writeFieldBegin('rawTextSpan', TType.STRUCT, 4)
            self.rawTextSpan.write(oprot)
            oprot.writeFieldEnd()
        if self.kind is not None:
            oprot.writeFieldBegin('kind', TType.STRING, 5)
            oprot.writeString(self.kind.encode('utf-8') if sys.version_info[0] == 2 else self.kind)
            oprot.writeFieldEnd()
        if self.label is not None:
            oprot.writeFieldBegin('label', TType.STRING, 6)
            oprot.writeString(self.label.encode('utf-8') if sys.version_info[0] == 2 else self.label)
            oprot.writeFieldEnd()
        if self.numberList is not None:
            oprot.writeFieldBegin('numberList', TType.LIST, 7)
            oprot.writeListBegin(TType.I32, len(self.numberList))
            for iter124 in self.numberList:
                oprot.writeI32(iter124)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lidList is not None:
            oprot.writeFieldBegin('lidList', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.lidList))
            for iter125 in self.lidList:
                iter125.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.audioSpan is not None:
            oprot.writeFieldBegin('audioSpan', TType.STRUCT, 9)
            self.audioSpan.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.kind is None:
            raise TProtocolException(message='Required field kind is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Constituent)
Constituent.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.STRING, 'tag', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'childList', (TType.I32, None, False), None, ),  # 3
    (4, TType.I32, 'headChildIndex', None, -1, ),  # 4
    (5, TType.I32, 'start', None, None, ),  # 5
    (6, TType.I32, 'ending', None, None, ),  # 6
)
all_structs.append(Parse)
Parse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'uuid', [concrete.uuid.ttypes.UUID, None], None, ),  # 1
    (2, TType.STRUCT, 'metadata', [concrete.metadata.ttypes.AnnotationMetadata, None], None, ),  # 2
    (3, TType.LIST, 'constituentList', (TType.STRUCT, [Constituent, None], False), None, ),  # 3
)
all_structs.append(ConstituentRef)
ConstituentRef.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'parseId', [concrete.uuid.ttypes.UUID, None], None, ),  # 1
    (2, TType.I32, 'constituentIndex', None, None, ),  # 2
)
all_structs.append(Dependency)
Dependency.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'gov', None, -1, ),  # 1
    (2, TType.I32, 'dep', None, None, ),  # 2
    (3, TType.STRING, 'edgeType', 'UTF8', None, ),  # 3
)
all_structs.append(DependencyParseStructure)
DependencyParseStructure.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'isAcyclic', None, None, ),  # 1
    (2, TType.BOOL, 'isConnected', None, None, ),  # 2
    (3, TType.BOOL, 'isSingleHeaded', None, None, ),  # 3
    (4, TType.BOOL, 'isProjective', None, None, ),  # 4
)
all_structs.append(DependencyParse)
DependencyParse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'uuid', [concrete.uuid.ttypes.UUID, None], None, ),  # 1
    (2, TType.STRUCT, 'metadata', [concrete.metadata.ttypes.AnnotationMetadata, None], None, ),  # 2
    (3, TType.LIST, 'dependencyList', (TType.STRUCT, [Dependency, None], False), None, ),  # 3
    (4, TType.STRUCT, 'structureInformation', [DependencyParseStructure, None], None, ),  # 4
)
all_structs.append(Token)
Token.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tokenIndex', None, None, ),  # 1
    (2, TType.STRING, 'text', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'textSpan', [concrete.spans.ttypes.TextSpan, None], None, ),  # 3
    (4, TType.STRUCT, 'rawTextSpan', [concrete.spans.ttypes.TextSpan, None], None, ),  # 4
    (5, TType.STRUCT, 'audioSpan', [concrete.spans.ttypes.AudioSpan, None], None, ),  # 5
)
all_structs.append(TokenRefSequence)
TokenRefSequence.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tokenIndexList', (TType.I32, None, False), None, ),  # 1
    (2, TType.I32, 'anchorTokenIndex', None, -1, ),  # 2
    (3, TType.STRUCT, 'tokenizationId', [concrete.uuid.ttypes.UUID, None], None, ),  # 3
    (4, TType.STRUCT, 'textSpan', [concrete.spans.ttypes.TextSpan, None], None, ),  # 4
    (5, TType.STRUCT, 'rawTextSpan', [concrete.spans.ttypes.TextSpan, None], None, ),  # 5
    (6, TType.STRUCT, 'audioSpan', [concrete.spans.ttypes.AudioSpan, None], None, ),  # 6
    (7, TType.LIST, 'dependencies', (TType.STRUCT, [Dependency, None], False), None, ),  # 7
    (8, TType.STRUCT, 'constituent', [ConstituentRef, None], None, ),  # 8
)
all_structs.append(TaggedToken)
TaggedToken.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tokenIndex', None, None, ),  # 1
    (2, TType.STRING, 'tag', 'UTF8', None, ),  # 2
    (3, TType.DOUBLE, 'confidence', None, None, ),  # 3
    (4, TType.LIST, 'tagList', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'confidenceList', (TType.DOUBLE, None, False), None, ),  # 5
)
all_structs.append(TokenTagging)
TokenTagging.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'uuid', [concrete.uuid.ttypes.UUID, None], None, ),  # 1
    (2, TType.STRUCT, 'metadata', [concrete.metadata.ttypes.AnnotationMetadata, None], None, ),  # 2
    (3, TType.LIST, 'taggedTokenList', (TType.STRUCT, [TaggedToken, None], False), None, ),  # 3
    (4, TType.STRING, 'taggingType', 'UTF8', None, ),  # 4
)
all_structs.append(LatticePath)
LatticePath.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'weight', None, None, ),  # 1
    (2, TType.LIST, 'tokenList', (TType.STRUCT, [Token, None], False), None, ),  # 2
)
all_structs.append(Arc)
Arc.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'src', None, None, ),  # 1
    (2, TType.I32, 'dst', None, None, ),  # 2
    (3, TType.STRUCT, 'token', [Token, None], None, ),  # 3
    (4, TType.DOUBLE, 'weight', None, None, ),  # 4
)
all_structs.append(TokenLattice)
TokenLattice.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'startState', None, 0, ),  # 1
    (2, TType.I32, 'endState', None, 0, ),  # 2
    (3, TType.LIST, 'arcList', (TType.STRUCT, [Arc, None], False), None, ),  # 3
    (4, TType.STRUCT, 'cachedBestPath', [LatticePath, None], None, ),  # 4
)
all_structs.append(TokenList)
TokenList.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tokenList', (TType.STRUCT, [Token, None], False), None, ),  # 1
)
all_structs.append(SpanLink)
SpanLink.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tokens', [TokenRefSequence, None], None, ),  # 1
    (2, TType.STRUCT, 'concreteTarget', [concrete.uuid.ttypes.UUID, None], None, ),  # 2
    (3, TType.STRING, 'externalTarget', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'linkType', 'UTF8', None, ),  # 4
)
all_structs.append(Tokenization)
Tokenization.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'uuid', [concrete.uuid.ttypes.UUID, None], None, ),  # 1
    (2, TType.STRUCT, 'metadata', [concrete.metadata.ttypes.AnnotationMetadata, None], None, ),  # 2
    (3, TType.STRUCT, 'tokenList', [TokenList, None], None, ),  # 3
    (4, TType.STRUCT, 'lattice', [TokenLattice, None], None, ),  # 4
    (5, TType.I32, 'kind', None, None, ),  # 5
    (6, TType.LIST, 'tokenTaggingList', (TType.STRUCT, [TokenTagging, None], False), None, ),  # 6
    (7, TType.LIST, 'parseList', (TType.STRUCT, [Parse, None], False), None, ),  # 7
    (8, TType.LIST, 'dependencyParseList', (TType.STRUCT, [DependencyParse, None], False), None, ),  # 8
    (9, TType.LIST, 'spanLinkList', (TType.STRUCT, [SpanLink, None], False), None, ),  # 9
)
all_structs.append(Sentence)
Sentence.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'uuid', [concrete.uuid.ttypes.UUID, None], None, ),  # 1
    (2, TType.STRUCT, 'tokenization', [Tokenization, None], None, ),  # 2
    (3, TType.STRUCT, 'textSpan', [concrete.spans.ttypes.TextSpan, None], None, ),  # 3
    (4, TType.STRUCT, 'rawTextSpan', [concrete.spans.ttypes.TextSpan, None], None, ),  # 4
    (5, TType.STRUCT, 'audioSpan', [concrete.spans.ttypes.AudioSpan, None], None, ),  # 5
)
all_structs.append(Section)
Section.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'uuid', [concrete.uuid.ttypes.UUID, None], None, ),  # 1
    (2, TType.LIST, 'sentenceList', (TType.STRUCT, [Sentence, None], False), None, ),  # 2
    (3, TType.STRUCT, 'textSpan', [concrete.spans.ttypes.TextSpan, None], None, ),  # 3
    (4, TType.STRUCT, 'rawTextSpan', [concrete.spans.ttypes.TextSpan, None], None, ),  # 4
    (5, TType.STRING, 'kind', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'label', 'UTF8', None, ),  # 6
    (7, TType.LIST, 'numberList', (TType.I32, None, False), None, ),  # 7
    (8, TType.LIST, 'lidList', (TType.STRUCT, [concrete.language.ttypes.LanguageIdentification, None], False), None, ),  # 8
    (9, TType.STRUCT, 'audioSpan', [concrete.spans.ttypes.AudioSpan, None], None, ),  # 9
)
fix_spec(all_structs)
del all_structs
