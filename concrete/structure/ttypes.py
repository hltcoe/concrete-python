# -*- coding: utf-8 -*-
#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style,utf8strings,coding=utf-8
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import concrete.metadata.ttypes
import concrete.spans.ttypes
import concrete.uuid.ttypes
import concrete.language.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TokenizationKind(object):
  """
  Enumerated types of Tokenizations
  """
  TOKEN_LIST = 1
  TOKEN_LATTICE = 2

  _VALUES_TO_NAMES = {
    1: "TOKEN_LIST",
    2: "TOKEN_LATTICE",
  }

  _NAMES_TO_VALUES = {
    "TOKEN_LIST": 1,
    "TOKEN_LATTICE": 2,
  }


class Token(object):
  """
  A single token (typically a word) in a communication. The exact
  definition of what counts as a token is left up to the tools that
  generate token sequences.

  Usually, each token will include at least a text string.

  Attributes:
   - tokenIndex: A 0-based tokenization-relative identifier for this token that
  represents the order that this token appears in the
  sentence. Together with the UUID for a Tokenization, this can be
  used to define pointers to specific tokens. If a Tokenization
  object contains multiple Token objects with the same id (e.g., in
  different n-best lists), then all of their other fields *must* be
  identical as well.
   - text: The text associated with this token.
  Note - we may have a destructive tokenizer (e.g., Stanford rewriting)
  and as a result, we want to maintain this field.
   - textSpan: Location of this token in this perspective's text (.text field).
  In cases where this token does not correspond directly with any
  text span in the text (such as word insertion during MT),
  this field may be given a value indicating "approximately" where
  the token comes from. A span covering the entire sentence may be
  used if no more precise value seems appropriate.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the document, but is the annotation's best
  effort at such a representation.
   - rawTextSpan: Location of this token in the original, raw text (.originalText
  field).  In cases where this token does not correspond directly
  with any text span in the original text (such as word insertion
  during MT), this field may be given a value indicating
  "approximately" where the token comes from. A span covering the
  entire sentence may be used if no more precise value seems
  appropriate.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original raw document, but is the annotation's best
  effort at such a representation.
   - audioSpan: Location of this token in the original audio.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tokenIndex', None, None, ), # 1
    (2, TType.STRING, 'text', None, None, ), # 2
    (3, TType.STRUCT, 'textSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'rawTextSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'audioSpan', (concrete.spans.ttypes.AudioSpan, concrete.spans.ttypes.AudioSpan.thrift_spec), None, ), # 5
  )

  def __init__(self, tokenIndex=None, text=None, textSpan=None, rawTextSpan=None, audioSpan=None,):
    self.tokenIndex = tokenIndex
    self.text = text
    self.textSpan = textSpan
    self.rawTextSpan = rawTextSpan
    self.audioSpan = audioSpan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tokenIndex = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.text = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.textSpan = concrete.spans.ttypes.TextSpan()
          self.textSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.rawTextSpan = concrete.spans.ttypes.TextSpan()
          self.rawTextSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.audioSpan = concrete.spans.ttypes.AudioSpan()
          self.audioSpan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Token')
    if self.tokenIndex is not None:
      oprot.writeFieldBegin('tokenIndex', TType.I32, 1)
      oprot.writeI32(self.tokenIndex)
      oprot.writeFieldEnd()
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 2)
      oprot.writeString(self.text.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.textSpan is not None:
      oprot.writeFieldBegin('textSpan', TType.STRUCT, 3)
      self.textSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.rawTextSpan is not None:
      oprot.writeFieldBegin('rawTextSpan', TType.STRUCT, 4)
      self.rawTextSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.audioSpan is not None:
      oprot.writeFieldBegin('audioSpan', TType.STRUCT, 5)
      self.audioSpan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tokenIndex is None:
      raise TProtocol.TProtocolException(message='Required field tokenIndex is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tokenIndex)
    value = (value * 31) ^ hash(self.text)
    value = (value * 31) ^ hash(self.textSpan)
    value = (value * 31) ^ hash(self.rawTextSpan)
    value = (value * 31) ^ hash(self.audioSpan)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConstituentRef(object):
  """
  A reference to a Constituent within a Parse.

  Attributes:
   - parseId: The UUID of the Parse that this Constituent belongs to.
   - constituentIndex: The index in the constituent list of this Constituent.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'parseId', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.I32, 'constituentIndex', None, None, ), # 2
  )

  def __init__(self, parseId=None, constituentIndex=None,):
    self.parseId = parseId
    self.constituentIndex = constituentIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.parseId = concrete.uuid.ttypes.UUID()
          self.parseId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.constituentIndex = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConstituentRef')
    if self.parseId is not None:
      oprot.writeFieldBegin('parseId', TType.STRUCT, 1)
      self.parseId.write(oprot)
      oprot.writeFieldEnd()
    if self.constituentIndex is not None:
      oprot.writeFieldBegin('constituentIndex', TType.I32, 2)
      oprot.writeI32(self.constituentIndex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.parseId is None:
      raise TProtocol.TProtocolException(message='Required field parseId is unset!')
    if self.constituentIndex is None:
      raise TProtocol.TProtocolException(message='Required field constituentIndex is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.parseId)
    value = (value * 31) ^ hash(self.constituentIndex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TokenRefSequence(object):
  """
  A list of pointers to tokens that all belong to the same
  tokenization.

  Attributes:
   - tokenIndexList: The tokenization-relative identifiers for each token that is
  included in this sequence.
   - anchorTokenIndex: An optional field that can be used to describe
  the root of a sentence (if this sequence is a full sentence),
  the head of a constituent (if this sequence is a constituent),
  or some other form of "canonical" token in this sequence if,
  for instance, it is not easy to map this sequence to a another
  annotation that has a head.

  This field is defined with respect to the Tokenization given
  by tokenizationId, and not to this object's tokenIndexList.
   - tokenizationId: The UUID of the tokenization that contains the tokens.
   - textSpan: The text span in the main text (.text field) associated with this
  TokenRefSequence.

  NOTE: This span represents a best guess, or 'provenance': it
  cannot be guaranteed that this text span matches the _exact_ text
  of the original document, but is the annotation's best effort at
  such a representation.
   - rawTextSpan: The text span in the original text (.originalText field)
  associated with this TokenRefSequence.

  NOTE: This span represents a best guess, or 'provenance': it
  cannot be guaranteed that this text span matches the _exact_ text
  of the original raw document, but is the annotation's best effort
  at such a representation.
   - audioSpan: The audio span associated with this TokenRefSequence.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tokenIndexList', (TType.I32,None), None, ), # 1
    (2, TType.I32, 'anchorTokenIndex', None, -1, ), # 2
    (3, TType.STRUCT, 'tokenizationId', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'textSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'rawTextSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'audioSpan', (concrete.spans.ttypes.AudioSpan, concrete.spans.ttypes.AudioSpan.thrift_spec), None, ), # 6
  )

  def __init__(self, tokenIndexList=None, anchorTokenIndex=thrift_spec[2][4], tokenizationId=None, textSpan=None, rawTextSpan=None, audioSpan=None,):
    self.tokenIndexList = tokenIndexList
    self.anchorTokenIndex = anchorTokenIndex
    self.tokenizationId = tokenizationId
    self.textSpan = textSpan
    self.rawTextSpan = rawTextSpan
    self.audioSpan = audioSpan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tokenIndexList = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI32()
            self.tokenIndexList.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.anchorTokenIndex = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.tokenizationId = concrete.uuid.ttypes.UUID()
          self.tokenizationId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.textSpan = concrete.spans.ttypes.TextSpan()
          self.textSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.rawTextSpan = concrete.spans.ttypes.TextSpan()
          self.rawTextSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.audioSpan = concrete.spans.ttypes.AudioSpan()
          self.audioSpan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TokenRefSequence')
    if self.tokenIndexList is not None:
      oprot.writeFieldBegin('tokenIndexList', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.tokenIndexList))
      for iter6 in self.tokenIndexList:
        oprot.writeI32(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.anchorTokenIndex is not None:
      oprot.writeFieldBegin('anchorTokenIndex', TType.I32, 2)
      oprot.writeI32(self.anchorTokenIndex)
      oprot.writeFieldEnd()
    if self.tokenizationId is not None:
      oprot.writeFieldBegin('tokenizationId', TType.STRUCT, 3)
      self.tokenizationId.write(oprot)
      oprot.writeFieldEnd()
    if self.textSpan is not None:
      oprot.writeFieldBegin('textSpan', TType.STRUCT, 4)
      self.textSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.rawTextSpan is not None:
      oprot.writeFieldBegin('rawTextSpan', TType.STRUCT, 5)
      self.rawTextSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.audioSpan is not None:
      oprot.writeFieldBegin('audioSpan', TType.STRUCT, 6)
      self.audioSpan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tokenIndexList is None:
      raise TProtocol.TProtocolException(message='Required field tokenIndexList is unset!')
    if self.tokenizationId is None:
      raise TProtocol.TProtocolException(message='Required field tokenizationId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tokenIndexList)
    value = (value * 31) ^ hash(self.anchorTokenIndex)
    value = (value * 31) ^ hash(self.tokenizationId)
    value = (value * 31) ^ hash(self.textSpan)
    value = (value * 31) ^ hash(self.rawTextSpan)
    value = (value * 31) ^ hash(self.audioSpan)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TaggedToken(object):
  """
  Attributes:
   - tokenIndex: A pointer to the token being tagged.

  Token indices are 0-based. These indices are also 0-based.
   - tag: A string containing the annotation.
  If the tag set you are using is not case sensitive,
  then all part of speech tags should be normalized to upper case.
   - confidence: Confidence of the annotation.
   - tagList: A list of strings that represent a distribution of possible
  tags for this token.

  If populated, the 'tag' field should also be populated
  with the "best" value from this list.
   - confidenceList: A list of doubles that represent confidences associated with
  the tags in the 'tagList' field.

  If populated, the 'confidence' field should also be populated
  with the confidence associated with the "best" tag in 'tagList'.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tokenIndex', None, None, ), # 1
    (2, TType.STRING, 'tag', None, None, ), # 2
    (3, TType.DOUBLE, 'confidence', None, None, ), # 3
    (4, TType.LIST, 'tagList', (TType.STRING,None), None, ), # 4
    (5, TType.LIST, 'confidenceList', (TType.DOUBLE,None), None, ), # 5
  )

  def __init__(self, tokenIndex=None, tag=None, confidence=None, tagList=None, confidenceList=None,):
    self.tokenIndex = tokenIndex
    self.tag = tag
    self.confidence = confidence
    self.tagList = tagList
    self.confidenceList = confidenceList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tokenIndex = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.confidence = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.tagList = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString().decode('utf-8')
            self.tagList.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.confidenceList = []
          (_etype16, _size13) = iprot.readListBegin()
          for _i17 in xrange(_size13):
            _elem18 = iprot.readDouble()
            self.confidenceList.append(_elem18)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaggedToken')
    if self.tokenIndex is not None:
      oprot.writeFieldBegin('tokenIndex', TType.I32, 1)
      oprot.writeI32(self.tokenIndex)
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRING, 2)
      oprot.writeString(self.tag.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.confidence is not None:
      oprot.writeFieldBegin('confidence', TType.DOUBLE, 3)
      oprot.writeDouble(self.confidence)
      oprot.writeFieldEnd()
    if self.tagList is not None:
      oprot.writeFieldBegin('tagList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.tagList))
      for iter19 in self.tagList:
        oprot.writeString(iter19.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.confidenceList is not None:
      oprot.writeFieldBegin('confidenceList', TType.LIST, 5)
      oprot.writeListBegin(TType.DOUBLE, len(self.confidenceList))
      for iter20 in self.confidenceList:
        oprot.writeDouble(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tokenIndex)
    value = (value * 31) ^ hash(self.tag)
    value = (value * 31) ^ hash(self.confidence)
    value = (value * 31) ^ hash(self.tagList)
    value = (value * 31) ^ hash(self.confidenceList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TokenTagging(object):
  """
  A theory about some token-level annotation.
  The TokenTagging consists of a mapping from tokens
  (using token ids) to string tags (e.g. part-of-speech tags or lemmas).

  The mapping defined by a TokenTagging may be partial --
  i.e., some tokens may not be assigned any part of speech tags.

  For lattice tokenizations, you may need to create multiple
  part-of-speech taggings (for different paths through the lattice),
  since the appropriate tag for a given token may depend on the path
  taken. For example, you might define a separate
  TokenTagging for each of the top K paths, which leaves all
  tokens that are not part of the path unlabeled.

  Currently, we use strings to encode annotations. In
  the future, we may add fields for encoding specific tag sets
  (eg treebank tags), or for adding compound tags.

  Attributes:
   - uuid: The UUID of this TokenTagging object.
   - metadata: Information about where the annotation came from.
  This should be used to tell between gold-standard annotations
  and automatically-generated theories about the data
   - taggedTokenList: The mapping from tokens to annotations.
  This may be a partial mapping.
   - taggingType: An ontology-backed string that represents the
  type of token taggings this TokenTagging object
  produces.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.LIST, 'taggedTokenList', (TType.STRUCT,(TaggedToken, TaggedToken.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'taggingType', None, None, ), # 4
  )

  def __init__(self, uuid=None, metadata=None, taggedTokenList=None, taggingType=None,):
    self.uuid = uuid
    self.metadata = metadata
    self.taggedTokenList = taggedTokenList
    self.taggingType = taggingType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.taggedTokenList = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = TaggedToken()
            _elem26.read(iprot)
            self.taggedTokenList.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.taggingType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TokenTagging')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.taggedTokenList is not None:
      oprot.writeFieldBegin('taggedTokenList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.taggedTokenList))
      for iter27 in self.taggedTokenList:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.taggingType is not None:
      oprot.writeFieldBegin('taggingType', TType.STRING, 4)
      oprot.writeString(self.taggingType.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.taggedTokenList is None:
      raise TProtocol.TProtocolException(message='Required field taggedTokenList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.taggedTokenList)
    value = (value * 31) ^ hash(self.taggingType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Dependency(object):
  """
  A syntactic edge between two tokens in a tokenized sentence.

  Attributes:
   - gov: The governor or the head token. 0 indexed.
   - dep: The dependent token. 0 indexed.
   - edgeType: The relation that holds between gov and dep.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gov', None, -1, ), # 1
    (2, TType.I32, 'dep', None, None, ), # 2
    (3, TType.STRING, 'edgeType', None, None, ), # 3
  )

  def __init__(self, gov=thrift_spec[1][4], dep=None, edgeType=None,):
    self.gov = gov
    self.dep = dep
    self.edgeType = edgeType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gov = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.dep = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.edgeType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Dependency')
    if self.gov is not None:
      oprot.writeFieldBegin('gov', TType.I32, 1)
      oprot.writeI32(self.gov)
      oprot.writeFieldEnd()
    if self.dep is not None:
      oprot.writeFieldBegin('dep', TType.I32, 2)
      oprot.writeI32(self.dep)
      oprot.writeFieldEnd()
    if self.edgeType is not None:
      oprot.writeFieldBegin('edgeType', TType.STRING, 3)
      oprot.writeString(self.edgeType.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dep is None:
      raise TProtocol.TProtocolException(message='Required field dep is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.gov)
    value = (value * 31) ^ hash(self.dep)
    value = (value * 31) ^ hash(self.edgeType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DependencyParseStructure(object):
  """
  Information about the structure of a dependency parse.
  This information is computable from the list of dependencies,
  but this allows the consumer to make (verified) assumptions
  about the dependencies being processed.

  Attributes:
   - isAcyclic: True iff there are no cycles in the dependency graph.
   - isConnected: True iff the dependency graph forms a single connected component.
   - isSingleHeaded: True iff every node in the dependency parse has at most
  one head/parent/governor.
   - isProjective: True iff there are no crossing edges in the dependency parse.
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isAcyclic', None, None, ), # 1
    (2, TType.BOOL, 'isConnected', None, None, ), # 2
    (3, TType.BOOL, 'isSingleHeaded', None, None, ), # 3
    (4, TType.BOOL, 'isProjective', None, None, ), # 4
  )

  def __init__(self, isAcyclic=None, isConnected=None, isSingleHeaded=None, isProjective=None,):
    self.isAcyclic = isAcyclic
    self.isConnected = isConnected
    self.isSingleHeaded = isSingleHeaded
    self.isProjective = isProjective

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isAcyclic = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isConnected = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isSingleHeaded = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isProjective = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DependencyParseStructure')
    if self.isAcyclic is not None:
      oprot.writeFieldBegin('isAcyclic', TType.BOOL, 1)
      oprot.writeBool(self.isAcyclic)
      oprot.writeFieldEnd()
    if self.isConnected is not None:
      oprot.writeFieldBegin('isConnected', TType.BOOL, 2)
      oprot.writeBool(self.isConnected)
      oprot.writeFieldEnd()
    if self.isSingleHeaded is not None:
      oprot.writeFieldBegin('isSingleHeaded', TType.BOOL, 3)
      oprot.writeBool(self.isSingleHeaded)
      oprot.writeFieldEnd()
    if self.isProjective is not None:
      oprot.writeFieldBegin('isProjective', TType.BOOL, 4)
      oprot.writeBool(self.isProjective)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.isAcyclic is None:
      raise TProtocol.TProtocolException(message='Required field isAcyclic is unset!')
    if self.isConnected is None:
      raise TProtocol.TProtocolException(message='Required field isConnected is unset!')
    if self.isSingleHeaded is None:
      raise TProtocol.TProtocolException(message='Required field isSingleHeaded is unset!')
    if self.isProjective is None:
      raise TProtocol.TProtocolException(message='Required field isProjective is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.isAcyclic)
    value = (value * 31) ^ hash(self.isConnected)
    value = (value * 31) ^ hash(self.isSingleHeaded)
    value = (value * 31) ^ hash(self.isProjective)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DependencyParse(object):
  """
  Represents a dependency parse with typed edges.

  Attributes:
   - uuid
   - metadata
   - dependencyList
   - structureInformation
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.LIST, 'dependencyList', (TType.STRUCT,(Dependency, Dependency.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'structureInformation', (DependencyParseStructure, DependencyParseStructure.thrift_spec), None, ), # 4
  )

  def __init__(self, uuid=None, metadata=None, dependencyList=None, structureInformation=None,):
    self.uuid = uuid
    self.metadata = metadata
    self.dependencyList = dependencyList
    self.structureInformation = structureInformation

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.dependencyList = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = Dependency()
            _elem33.read(iprot)
            self.dependencyList.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.structureInformation = DependencyParseStructure()
          self.structureInformation.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DependencyParse')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.dependencyList is not None:
      oprot.writeFieldBegin('dependencyList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.dependencyList))
      for iter34 in self.dependencyList:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.structureInformation is not None:
      oprot.writeFieldBegin('structureInformation', TType.STRUCT, 4)
      self.structureInformation.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.dependencyList is None:
      raise TProtocol.TProtocolException(message='Required field dependencyList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.dependencyList)
    value = (value * 31) ^ hash(self.structureInformation)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Constituent(object):
  """
  A single parse constituent (or "phrase").

  Attributes:
   - id: A parse-relative identifier for this consistuent. Together
  with the UUID for a Parse, this can be used to define
  pointers to specific constituents.
   - tag: A description of this constituency node, e.g. the category "NP".
  For leaf nodes, this should be a word and for pre-terminal nodes
  this should be a POS tag.
   - childList
   - headChildIndex: The index of the head child of this constituent. I.e., the
  head child of constituent <tt>c</tt> is
  <tt>c.children[c.head_child_index]</tt>. A value of -1
  indicates that no child head was identified.
   - start: The first token (inclusive) of this constituent in the
  parent Tokenization. Almost certainly should be populated.
   - ending: The last token (exclusive) of this constituent in the
  parent Tokenization. Almost certainly should be populated.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, None, ), # 1
    (2, TType.STRING, 'tag', None, None, ), # 2
    (3, TType.LIST, 'childList', (TType.I32,None), None, ), # 3
    (4, TType.I32, 'headChildIndex', None, -1, ), # 4
    (5, TType.I32, 'start', None, None, ), # 5
    (6, TType.I32, 'ending', None, None, ), # 6
  )

  def __init__(self, id=None, tag=None, childList=None, headChildIndex=thrift_spec[4][4], start=None, ending=None,):
    self.id = id
    self.tag = tag
    self.childList = childList
    self.headChildIndex = headChildIndex
    self.start = start
    self.ending = ending

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.childList = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = iprot.readI32()
            self.childList.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.headChildIndex = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.start = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.ending = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Constituent')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRING, 2)
      oprot.writeString(self.tag.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.childList is not None:
      oprot.writeFieldBegin('childList', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.childList))
      for iter41 in self.childList:
        oprot.writeI32(iter41)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.headChildIndex is not None:
      oprot.writeFieldBegin('headChildIndex', TType.I32, 4)
      oprot.writeI32(self.headChildIndex)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I32, 5)
      oprot.writeI32(self.start)
      oprot.writeFieldEnd()
    if self.ending is not None:
      oprot.writeFieldBegin('ending', TType.I32, 6)
      oprot.writeI32(self.ending)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.childList is None:
      raise TProtocol.TProtocolException(message='Required field childList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.tag)
    value = (value * 31) ^ hash(self.childList)
    value = (value * 31) ^ hash(self.headChildIndex)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.ending)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Parse(object):
  """
  A theory about the syntactic parse of a sentence.

  \note If we add support for parse forests in the future, then it
  will most likely be done by adding a new field (e.g.
  "<tt>forest_root</tt>") that uses a new struct type to encode the
  forest. A "<tt>kind</tt>" field might also be added (analogous to
  <tt>Tokenization.kind</tt>) to indicate whether a parse is encoded
  using a simple tree or a parse forest.

  Attributes:
   - uuid
   - metadata
   - constituentList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.LIST, 'constituentList', (TType.STRUCT,(Constituent, Constituent.thrift_spec)), None, ), # 3
  )

  def __init__(self, uuid=None, metadata=None, constituentList=None,):
    self.uuid = uuid
    self.metadata = metadata
    self.constituentList = constituentList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.constituentList = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = Constituent()
            _elem47.read(iprot)
            self.constituentList.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Parse')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.constituentList is not None:
      oprot.writeFieldBegin('constituentList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.constituentList))
      for iter48 in self.constituentList:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.constituentList is None:
      raise TProtocol.TProtocolException(message='Required field constituentList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.constituentList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LatticePath(object):
  """
  Attributes:
   - weight
   - tokenList
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'weight', None, None, ), # 1
    (2, TType.LIST, 'tokenList', (TType.STRUCT,(Token, Token.thrift_spec)), None, ), # 2
  )

  def __init__(self, weight=None, tokenList=None,):
    self.weight = weight
    self.tokenList = tokenList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.weight = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tokenList = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = Token()
            _elem54.read(iprot)
            self.tokenList.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LatticePath')
    if self.weight is not None:
      oprot.writeFieldBegin('weight', TType.DOUBLE, 1)
      oprot.writeDouble(self.weight)
      oprot.writeFieldEnd()
    if self.tokenList is not None:
      oprot.writeFieldBegin('tokenList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tokenList))
      for iter55 in self.tokenList:
        iter55.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tokenList is None:
      raise TProtocol.TProtocolException(message='Required field tokenList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.weight)
    value = (value * 31) ^ hash(self.tokenList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Arc(object):
  """
  Type for arcs. For epsilon edges, leave 'token' blank.

  Attributes:
   - src
   - dst
   - token
   - weight
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'src', None, None, ), # 1
    (2, TType.I32, 'dst', None, None, ), # 2
    (3, TType.STRUCT, 'token', (Token, Token.thrift_spec), None, ), # 3
    (4, TType.DOUBLE, 'weight', None, None, ), # 4
  )

  def __init__(self, src=None, dst=None, token=None, weight=None,):
    self.src = src
    self.dst = dst
    self.token = token
    self.weight = weight

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.src = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.dst = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.token = Token()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.weight = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Arc')
    if self.src is not None:
      oprot.writeFieldBegin('src', TType.I32, 1)
      oprot.writeI32(self.src)
      oprot.writeFieldEnd()
    if self.dst is not None:
      oprot.writeFieldBegin('dst', TType.I32, 2)
      oprot.writeI32(self.dst)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 3)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.weight is not None:
      oprot.writeFieldBegin('weight', TType.DOUBLE, 4)
      oprot.writeDouble(self.weight)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.src)
    value = (value * 31) ^ hash(self.dst)
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.weight)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TokenLattice(object):
  """
  A lattice structure that assigns scores to a set of token
  sequences.  The lattice is encoded as an FSA, where states are
  identified by integers, and each arc is annotated with an
  optional tokens and a weight.  (Arcs with no tokens are
  "epsilon" arcs.)  The lattice has a single start state and a
  single end state.  (You can use epsilon edges to simulate
  multiple start states or multiple end states, if desired.)

  The score of a path through the lattice is the sum of the weights
  of the arcs that make up that path.  A path with a lower score
  is considered "better" than a path with a higher score.

  If possible, path scores should be negative log likelihoods
  (with base e -- e.g. if P=1, then weight=0; and if P=0.5, then
  weight=0.693).  Furthermore, if possible, the path scores should
  be globally normalized (i.e., they should encode probabilities).
  This will allow for them to be combined with other information
  in a reasonable way when determining confidences for system
  outputs.

  TokenLattices should never contain any paths with cycles.  Every
  arc in the lattice should be included in some path from the start
  state to the end state.

  Attributes:
   - startState
   - endState
   - arcList
   - cachedBestPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'startState', None, 0, ), # 1
    (2, TType.I32, 'endState', None, 0, ), # 2
    (3, TType.LIST, 'arcList', (TType.STRUCT,(Arc, Arc.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'cachedBestPath', (LatticePath, LatticePath.thrift_spec), None, ), # 4
  )

  def __init__(self, startState=thrift_spec[1][4], endState=thrift_spec[2][4], arcList=None, cachedBestPath=None,):
    self.startState = startState
    self.endState = endState
    self.arcList = arcList
    self.cachedBestPath = cachedBestPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.startState = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.endState = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.arcList = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = Arc()
            _elem61.read(iprot)
            self.arcList.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.cachedBestPath = LatticePath()
          self.cachedBestPath.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TokenLattice')
    if self.startState is not None:
      oprot.writeFieldBegin('startState', TType.I32, 1)
      oprot.writeI32(self.startState)
      oprot.writeFieldEnd()
    if self.endState is not None:
      oprot.writeFieldBegin('endState', TType.I32, 2)
      oprot.writeI32(self.endState)
      oprot.writeFieldEnd()
    if self.arcList is not None:
      oprot.writeFieldBegin('arcList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.arcList))
      for iter62 in self.arcList:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.cachedBestPath is not None:
      oprot.writeFieldBegin('cachedBestPath', TType.STRUCT, 4)
      self.cachedBestPath.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.arcList is None:
      raise TProtocol.TProtocolException(message='Required field arcList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startState)
    value = (value * 31) ^ hash(self.endState)
    value = (value * 31) ^ hash(self.arcList)
    value = (value * 31) ^ hash(self.cachedBestPath)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TokenList(object):
  """
  A wrapper around a list of tokens.

  Attributes:
   - tokenList
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tokenList', (TType.STRUCT,(Token, Token.thrift_spec)), None, ), # 1
  )

  def __init__(self, tokenList=None,):
    self.tokenList = tokenList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tokenList = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = Token()
            _elem68.read(iprot)
            self.tokenList.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TokenList')
    if self.tokenList is not None:
      oprot.writeFieldBegin('tokenList', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tokenList))
      for iter69 in self.tokenList:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tokenList is None:
      raise TProtocol.TProtocolException(message='Required field tokenList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tokenList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SpanLink(object):
  """
  A collection of tokens that represent a link to another resource.
  This resource might be another Concrete object (e.g., another
  Concrete Communication), represented with the 'concreteTarget'
  field, or it could link to a resource outside of Concrete via the
  'externalTarget' field.

  Attributes:
   - tokens: The tokens that make up this SpanLink object.
   - concreteTarget
   - externalTarget
   - linkType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tokens', (TokenRefSequence, TokenRefSequence.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'concreteTarget', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 2
    (3, TType.STRING, 'externalTarget', None, None, ), # 3
    (4, TType.STRING, 'linkType', None, None, ), # 4
  )

  def __init__(self, tokens=None, concreteTarget=None, externalTarget=None, linkType=None,):
    self.tokens = tokens
    self.concreteTarget = concreteTarget
    self.externalTarget = externalTarget
    self.linkType = linkType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tokens = TokenRefSequence()
          self.tokens.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.concreteTarget = concrete.uuid.ttypes.UUID()
          self.concreteTarget.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.externalTarget = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.linkType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SpanLink')
    if self.tokens is not None:
      oprot.writeFieldBegin('tokens', TType.STRUCT, 1)
      self.tokens.write(oprot)
      oprot.writeFieldEnd()
    if self.concreteTarget is not None:
      oprot.writeFieldBegin('concreteTarget', TType.STRUCT, 2)
      self.concreteTarget.write(oprot)
      oprot.writeFieldEnd()
    if self.externalTarget is not None:
      oprot.writeFieldBegin('externalTarget', TType.STRING, 3)
      oprot.writeString(self.externalTarget.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.linkType is not None:
      oprot.writeFieldBegin('linkType', TType.STRING, 4)
      oprot.writeString(self.linkType.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tokens is None:
      raise TProtocol.TProtocolException(message='Required field tokens is unset!')
    if self.linkType is None:
      raise TProtocol.TProtocolException(message='Required field linkType is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tokens)
    value = (value * 31) ^ hash(self.concreteTarget)
    value = (value * 31) ^ hash(self.externalTarget)
    value = (value * 31) ^ hash(self.linkType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Tokenization(object):
  """
  A theory (or set of alternative theories) about the sequence of
  tokens that make up a sentence.

  This message type is used to record the output of not just for
  tokenizers, but also for a wide variety of other tools, including
  machine translation systems, text normalizers, part-of-speech
  taggers, and stemmers.

  Each Tokenization is encoded using either a TokenList
  or a TokenLattice. (If you want to encode an n-best list, then
  you should store it as n separate Tokenization objects.) The
  "kind" field is used to indicate whether this Tokenization contains
  a list of tokens or a TokenLattice.

  The confidence value for each sequence is determined by combining
  the confidence from the "metadata" field with confidence
  information from individual token sequences as follows:

  <ul>
  <li> For n-best lists:
  metadata.confidence </li>
  <li> For lattices:
  metadata.confidence * exp(-sum(arc.weight)) </li>
  </ul>

  Note: in some cases (such as the output of a machine translation
  tool), the order of the tokens in a token sequence may not
  correspond with the order of their original text span offsets.

  Attributes:
   - uuid
   - metadata: Information about where this tokenization came from.
   - tokenList: A wrapper around an ordered list of the tokens in this tokenization.
  This may also give easy access to the "reconstructed text" associated
  with this tokenization.
  This field should only have a value if kind==TOKEN_LIST.
   - lattice: A lattice that compactly describes a set of token sequences that
  might make up this tokenization.  This field should only have a
  value if kind==LATTICE.
   - kind: Enumerated value indicating whether this tokenization is
  implemented using an n-best list or a lattice.
   - tokenTaggingList
   - parseList
   - dependencyParseList
   - spanLinkList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'tokenList', (TokenList, TokenList.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'lattice', (TokenLattice, TokenLattice.thrift_spec), None, ), # 4
    (5, TType.I32, 'kind', None, None, ), # 5
    (6, TType.LIST, 'tokenTaggingList', (TType.STRUCT,(TokenTagging, TokenTagging.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'parseList', (TType.STRUCT,(Parse, Parse.thrift_spec)), None, ), # 7
    (8, TType.LIST, 'dependencyParseList', (TType.STRUCT,(DependencyParse, DependencyParse.thrift_spec)), None, ), # 8
    (9, TType.LIST, 'spanLinkList', (TType.STRUCT,(SpanLink, SpanLink.thrift_spec)), None, ), # 9
  )

  def __init__(self, uuid=None, metadata=None, tokenList=None, lattice=None, kind=None, tokenTaggingList=None, parseList=None, dependencyParseList=None, spanLinkList=None,):
    self.uuid = uuid
    self.metadata = metadata
    self.tokenList = tokenList
    self.lattice = lattice
    self.kind = kind
    self.tokenTaggingList = tokenTaggingList
    self.parseList = parseList
    self.dependencyParseList = dependencyParseList
    self.spanLinkList = spanLinkList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.tokenList = TokenList()
          self.tokenList.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.lattice = TokenLattice()
          self.lattice.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.kind = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.tokenTaggingList = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = TokenTagging()
            _elem75.read(iprot)
            self.tokenTaggingList.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.parseList = []
          (_etype79, _size76) = iprot.readListBegin()
          for _i80 in xrange(_size76):
            _elem81 = Parse()
            _elem81.read(iprot)
            self.parseList.append(_elem81)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.dependencyParseList = []
          (_etype85, _size82) = iprot.readListBegin()
          for _i86 in xrange(_size82):
            _elem87 = DependencyParse()
            _elem87.read(iprot)
            self.dependencyParseList.append(_elem87)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.spanLinkList = []
          (_etype91, _size88) = iprot.readListBegin()
          for _i92 in xrange(_size88):
            _elem93 = SpanLink()
            _elem93.read(iprot)
            self.spanLinkList.append(_elem93)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Tokenization')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.tokenList is not None:
      oprot.writeFieldBegin('tokenList', TType.STRUCT, 3)
      self.tokenList.write(oprot)
      oprot.writeFieldEnd()
    if self.lattice is not None:
      oprot.writeFieldBegin('lattice', TType.STRUCT, 4)
      self.lattice.write(oprot)
      oprot.writeFieldEnd()
    if self.kind is not None:
      oprot.writeFieldBegin('kind', TType.I32, 5)
      oprot.writeI32(self.kind)
      oprot.writeFieldEnd()
    if self.tokenTaggingList is not None:
      oprot.writeFieldBegin('tokenTaggingList', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.tokenTaggingList))
      for iter94 in self.tokenTaggingList:
        iter94.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parseList is not None:
      oprot.writeFieldBegin('parseList', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.parseList))
      for iter95 in self.parseList:
        iter95.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dependencyParseList is not None:
      oprot.writeFieldBegin('dependencyParseList', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.dependencyParseList))
      for iter96 in self.dependencyParseList:
        iter96.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.spanLinkList is not None:
      oprot.writeFieldBegin('spanLinkList', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.spanLinkList))
      for iter97 in self.spanLinkList:
        iter97.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.kind is None:
      raise TProtocol.TProtocolException(message='Required field kind is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.tokenList)
    value = (value * 31) ^ hash(self.lattice)
    value = (value * 31) ^ hash(self.kind)
    value = (value * 31) ^ hash(self.tokenTaggingList)
    value = (value * 31) ^ hash(self.parseList)
    value = (value * 31) ^ hash(self.dependencyParseList)
    value = (value * 31) ^ hash(self.spanLinkList)
    return value

  def __repr__(self):
    # The implementation of this function is NOT auto-generated
    # Prevent infinite recursion caused by backpointer added by
    #   concrete.util.references.add_references_to_communication()
    dict_without_backpointer = self.__dict__.copy()
    if 'sentence' in dict_without_backpointer:
      dict_without_backpointer.pop('sentence')
    L = ['%s=%r' % (key, value)
      for key, value in dict_without_backpointer.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Sentence(object):
  """
  A single sentence or utterance in a communication.

  Attributes:
   - uuid
   - tokenization: Theory about the tokens that make up this sentence.  For text
  communications, these tokenizations will typically be generated
  by a tokenizer.  For audio communications, these tokenizations
  will typically be generated by an automatic speech recognizer.

  The "Tokenization" message type is also used to store the output
  of machine translation systems and text normalization
  systems.
   - textSpan: Location of this sentence in the communication text.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
   - rawTextSpan: Location of this sentence in the raw text.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
   - audioSpan: Location of this sentence in the original audio.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'tokenization', (Tokenization, Tokenization.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'textSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'rawTextSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'audioSpan', (concrete.spans.ttypes.AudioSpan, concrete.spans.ttypes.AudioSpan.thrift_spec), None, ), # 5
  )

  def __init__(self, uuid=None, tokenization=None, textSpan=None, rawTextSpan=None, audioSpan=None,):
    self.uuid = uuid
    self.tokenization = tokenization
    self.textSpan = textSpan
    self.rawTextSpan = rawTextSpan
    self.audioSpan = audioSpan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tokenization = Tokenization()
          self.tokenization.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.textSpan = concrete.spans.ttypes.TextSpan()
          self.textSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.rawTextSpan = concrete.spans.ttypes.TextSpan()
          self.rawTextSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.audioSpan = concrete.spans.ttypes.AudioSpan()
          self.audioSpan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Sentence')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.tokenization is not None:
      oprot.writeFieldBegin('tokenization', TType.STRUCT, 2)
      self.tokenization.write(oprot)
      oprot.writeFieldEnd()
    if self.textSpan is not None:
      oprot.writeFieldBegin('textSpan', TType.STRUCT, 3)
      self.textSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.rawTextSpan is not None:
      oprot.writeFieldBegin('rawTextSpan', TType.STRUCT, 4)
      self.rawTextSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.audioSpan is not None:
      oprot.writeFieldBegin('audioSpan', TType.STRUCT, 5)
      self.audioSpan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.tokenization)
    value = (value * 31) ^ hash(self.textSpan)
    value = (value * 31) ^ hash(self.rawTextSpan)
    value = (value * 31) ^ hash(self.audioSpan)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Section(object):
  """
  A single "section" of a communication, such as a paragraph. Each
  section is defined using a text or audio span, and can optionally
  contain a list of sentences.

  Attributes:
   - uuid: The unique identifier for this section.
   - sentenceList: Theories about how this section is divided into sentences.
   - textSpan: Location of this section in the communication text.

  NOTE: This text span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
   - rawTextSpan: Location of this section in the raw text.

  NOTE: This text span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
   - audioSpan: Location of this section in the original audio.

  NOTE: This span represents a best guess, or 'provenance':
  it cannot be guaranteed that this text span matches the _exact_
  text of the original document, but is the annotation's best
  effort at such a representation.
   - kind: The type of this section.
   - label: The name of the section. For example, a title of a section on
  Wikipedia.
   - numberList: Position within the communication with respect to other Sections:
  The section number, E.g., 3, or 3.1, or 3.1.2, etc. Aimed at
  Communications with content organized in a hierarchy, such as a Book
  with multiple chapters, then sections, then paragraphs. Or even a
  dense Wikipedia page with subsections. Sections should still be
  arranged linearly, where reading these numbers should not be required
  to get a start-to-finish enumeration of the Communication's content.
   - lidList: An optional field to be used for multi-language documents.

  This field should be populated when a section is inside of
  a document that contains multiple languages.

  Minimally, each block of text in one language should be it's own
  section. For example, if a paragraph is in English and the
  paragraph afterwards is in French, these should be separated into
  two different sections, allowing language-specific analytics to
  run on appropriate sections.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uuid', (concrete.uuid.ttypes.UUID, concrete.uuid.ttypes.UUID.thrift_spec), None, ), # 1
    (2, TType.LIST, 'sentenceList', (TType.STRUCT,(Sentence, Sentence.thrift_spec)), None, ), # 2
    (3, TType.STRUCT, 'textSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'rawTextSpan', (concrete.spans.ttypes.TextSpan, concrete.spans.ttypes.TextSpan.thrift_spec), None, ), # 4
    (5, TType.STRING, 'kind', None, None, ), # 5
    (6, TType.STRING, 'label', None, None, ), # 6
    (7, TType.LIST, 'numberList', (TType.I32,None), None, ), # 7
    (8, TType.LIST, 'lidList', (TType.STRUCT,(concrete.language.ttypes.LanguageIdentification, concrete.language.ttypes.LanguageIdentification.thrift_spec)), None, ), # 8
    (9, TType.STRUCT, 'audioSpan', (concrete.spans.ttypes.AudioSpan, concrete.spans.ttypes.AudioSpan.thrift_spec), None, ), # 9
  )

  def __init__(self, uuid=None, sentenceList=None, textSpan=None, rawTextSpan=None, audioSpan=None, kind=None, label=None, numberList=None, lidList=None,):
    self.uuid = uuid
    self.sentenceList = sentenceList
    self.textSpan = textSpan
    self.rawTextSpan = rawTextSpan
    self.audioSpan = audioSpan
    self.kind = kind
    self.label = label
    self.numberList = numberList
    self.lidList = lidList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uuid = concrete.uuid.ttypes.UUID()
          self.uuid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.sentenceList = []
          (_etype101, _size98) = iprot.readListBegin()
          for _i102 in xrange(_size98):
            _elem103 = Sentence()
            _elem103.read(iprot)
            self.sentenceList.append(_elem103)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.textSpan = concrete.spans.ttypes.TextSpan()
          self.textSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.rawTextSpan = concrete.spans.ttypes.TextSpan()
          self.rawTextSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.audioSpan = concrete.spans.ttypes.AudioSpan()
          self.audioSpan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.kind = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.label = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.numberList = []
          (_etype107, _size104) = iprot.readListBegin()
          for _i108 in xrange(_size104):
            _elem109 = iprot.readI32()
            self.numberList.append(_elem109)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.lidList = []
          (_etype113, _size110) = iprot.readListBegin()
          for _i114 in xrange(_size110):
            _elem115 = concrete.language.ttypes.LanguageIdentification()
            _elem115.read(iprot)
            self.lidList.append(_elem115)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Section')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRUCT, 1)
      self.uuid.write(oprot)
      oprot.writeFieldEnd()
    if self.sentenceList is not None:
      oprot.writeFieldBegin('sentenceList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.sentenceList))
      for iter116 in self.sentenceList:
        iter116.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.textSpan is not None:
      oprot.writeFieldBegin('textSpan', TType.STRUCT, 3)
      self.textSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.rawTextSpan is not None:
      oprot.writeFieldBegin('rawTextSpan', TType.STRUCT, 4)
      self.rawTextSpan.write(oprot)
      oprot.writeFieldEnd()
    if self.kind is not None:
      oprot.writeFieldBegin('kind', TType.STRING, 5)
      oprot.writeString(self.kind.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.label is not None:
      oprot.writeFieldBegin('label', TType.STRING, 6)
      oprot.writeString(self.label.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.numberList is not None:
      oprot.writeFieldBegin('numberList', TType.LIST, 7)
      oprot.writeListBegin(TType.I32, len(self.numberList))
      for iter117 in self.numberList:
        oprot.writeI32(iter117)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.lidList is not None:
      oprot.writeFieldBegin('lidList', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.lidList))
      for iter118 in self.lidList:
        iter118.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.audioSpan is not None:
      oprot.writeFieldBegin('audioSpan', TType.STRUCT, 9)
      self.audioSpan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uuid is None:
      raise TProtocol.TProtocolException(message='Required field uuid is unset!')
    if self.kind is None:
      raise TProtocol.TProtocolException(message='Required field kind is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.sentenceList)
    value = (value * 31) ^ hash(self.textSpan)
    value = (value * 31) ^ hash(self.rawTextSpan)
    value = (value * 31) ^ hash(self.audioSpan)
    value = (value * 31) ^ hash(self.kind)
    value = (value * 31) ^ hash(self.label)
    value = (value * 31) ^ hash(self.numberList)
    value = (value * 31) ^ hash(self.lidList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
